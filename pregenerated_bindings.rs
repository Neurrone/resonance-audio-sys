/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct equal_to {
            pub _address: u8,
        }
        pub type equal_to_first_argument_type = u8;
        pub type equal_to_second_argument_type = u8;
        pub type equal_to_result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct hash {
            pub _address: u8,
        }
        pub mod _DEPRECATE_TR1_NAMESPACE {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic__My_base = u8;
        pub type atomic_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__Not_user_specialized = u8;
        pub type allocator_value_type = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Mybase = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct enable_shared_from_this {
            pub _address: u8,
        }
        pub type enable_shared_from_this__Esft_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct unique_ptr {
            pub _address: u8,
        }
        pub type unique_ptr__Mybase = u8;
        pub type unique_ptr_pointer = u8;
        pub type unique_ptr_element_type = u8;
        pub type unique_ptr_deleter_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Mybase = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string__Alty = u8;
        pub type basic_string__Alty_traits = u8;
        pub type basic_string__Mydata_t = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string__Use_memcpy_move = u8;
        pub type basic_string__Is_elem_cptr = u8;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Mybase = u8;
        pub type vector__Alty = u8;
        pub type vector__Alty_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct list {
            pub _address: u8,
        }
        pub type list__Mybase = u8;
        pub type list__Node = u8;
        pub type list__Nodeptr = u8;
        pub type list__Alnode = u8;
        pub type list__Alnode_traits = u8;
        pub type list_value_type = u8;
        pub type list_allocator_type = u8;
        pub type list_size_type = u8;
        pub type list_difference_type = u8;
        pub type list_pointer = u8;
        pub type list_const_pointer = u8;
        pub type list_reference = u8;
        pub type list_const_reference = u8;
        pub type list_iterator = u8;
        pub type list_const_iterator = u8;
        pub type list__Unchecked_iterator = u8;
        pub type list__Unchecked_const_iterator = u8;
        pub type list_reverse_iterator = u8;
        pub type list_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub type unordered_map__Mytraits = u8;
        pub type unordered_map__Mybase = u8;
        pub type unordered_map_hasher = u8;
        pub type unordered_map_key_type = u8;
        pub type unordered_map_mapped_type = u8;
        pub type unordered_map_key_equal = u8;
        pub type unordered_map_key_compare = u8;
        pub type unordered_map_value_type = u8;
        pub type unordered_map_allocator_type = u8;
        pub type unordered_map_size_type = u8;
        pub type unordered_map_difference_type = u8;
        pub type unordered_map_pointer = u8;
        pub type unordered_map_const_pointer = u8;
        pub type unordered_map_reference = u8;
        pub type unordered_map_const_reference = u8;
        pub type unordered_map_iterator = u8;
        pub type unordered_map_const_iterator = u8;
        pub type unordered_map_local_iterator = u8;
        pub type unordered_map_const_local_iterator = u8;
        pub type unordered_map__Alnode = u8;
        pub type unordered_map__Alnode_traits = u8;
        pub type unordered_map__Pairib = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct function {
            pub _address: u8,
        }
        pub type function__Mybase = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct set {
            pub _address: u8,
        }
        pub type set__Mybase = u8;
        pub type set_key_type = u8;
        pub type set_key_compare = u8;
        pub type set_value_compare = u8;
        pub type set_value_type = u8;
        pub type set_allocator_type = u8;
        pub type set_size_type = u8;
        pub type set_difference_type = u8;
        pub type set_pointer = u8;
        pub type set_const_pointer = u8;
        pub type set_reference = u8;
        pub type set_const_reference = u8;
        pub type set_iterator = u8;
        pub type set_const_iterator = u8;
        pub type set_reverse_iterator = u8;
        pub type set_const_reverse_iterator = u8;
        pub type set__Alnode = u8;
        pub type set__Alnode_traits = u8;
    }
    /// int16_t declaration.
    pub type int16 = ::std::os::raw::c_short;
    pub mod vraudio {
        #[allow(unused_imports)]
        use self::super::super::root;
        /// Stereo panning, i.e., this disables HRTF-based rendering.
        pub const RenderingMode_kStereoPanning: root::vraudio::RenderingMode = 0;
        /// HRTF-based rendering using First Order Ambisonics, over a virtual array of
        /// /// 8 loudspeakers arranged in a cube configuration around the listener's head.
        pub const RenderingMode_kBinauralLowQuality: root::vraudio::RenderingMode = 1;
        /// HRTF-based rendering using Second Order Ambisonics, over a virtual array of
        /// /// 12 loudspeakers arranged in a dodecahedral configuration (using faces of
        /// /// the dodecahedron).
        pub const RenderingMode_kBinauralMediumQuality: root::vraudio::RenderingMode = 2;
        /// HRTF-based rendering using Third Order Ambisonics, over a virtual array of
        /// /// 26 loudspeakers arranged in a Lebedev grid: https://goo.gl/DX1wh3.
        pub const RenderingMode_kBinauralHighQuality: root::vraudio::RenderingMode = 3;
        /// Room effects only rendering. This disables HRTF-based rendering and direct
        /// /// (dry) output of a sound object. Note that this rendering mode should *not*
        /// /// be used for general-purpose sound object spatialization, as it will only
        /// /// render the corresponding room effects of given sound objects without the
        /// /// direct spatialization.
        pub const RenderingMode_kRoomEffectsOnly: root::vraudio::RenderingMode = 4;
        /// Rendering modes define CPU load / rendering quality balances.
        /// Note that this struct is C-compatible by design to be used across external
        /// C/C++ and C# implementations.
        pub type RenderingMode = i32;
        /// Logarithmic distance rolloff model.
        pub const DistanceRolloffModel_kLogarithmic: root::vraudio::DistanceRolloffModel = 0;
        /// Linear distance rolloff model.
        pub const DistanceRolloffModel_kLinear: root::vraudio::DistanceRolloffModel = 1;
        /// Distance attenuation value will be explicitly set by the user.
        pub const DistanceRolloffModel_kNone: root::vraudio::DistanceRolloffModel = 2;
        /// Distance rolloff models used for distance attenuation.
        /// Note that this enum is C-compatible by design to be used across external
        /// C/C++ and C# implementations.
        pub type DistanceRolloffModel = i32;
        /// Early reflection properties of an acoustic environment.
        /// Note that this struct is C-compatible by design to be used across external
        /// C/C++ and C# implementations.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReflectionProperties {
            /// Center position of the shoebox room in world space.
            pub room_position: [f32; 3usize],
            /// Rotation (quaternion) of the shoebox room in world space.
            pub room_rotation: [f32; 4usize],
            /// Size of the shoebox shoebox room in world space.
            pub room_dimensions: [f32; 3usize],
            /// Frequency threshold for low pass filtering (-3dB cuttoff).
            pub cutoff_frequency: f32,
            /// Reflection coefficients that are stored in world space as follows:
            /// ///  [0]  (-)ive x-axis wall (left)
            /// ///  [1]  (+)ive x-axis wall (right)
            /// ///  [2]  (-)ive y-axis wall (bottom)
            /// ///  [3]  (+)ive y-axis wall (top)
            /// ///  [4]  (-)ive z-axis wall (front)
            /// ///  [5]  (+)ive z-axis wall (back)
            pub coefficients: [f32; 6usize],
            /// Uniform reflections gain which is applied to all reflections.
            pub gain: f32,
        }
        #[test]
        fn bindgen_test_layout_ReflectionProperties() {
            assert_eq!(
                ::std::mem::size_of::<ReflectionProperties>(),
                72usize,
                concat!("Size of: ", stringify!(ReflectionProperties))
            );
            assert_eq!(
                ::std::mem::align_of::<ReflectionProperties>(),
                4usize,
                concat!("Alignment of ", stringify!(ReflectionProperties))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).room_position as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(room_position)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).room_rotation as *const _
                        as usize
                },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(room_rotation)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).room_dimensions as *const _
                        as usize
                },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(room_dimensions)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).cutoff_frequency as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(cutoff_frequency)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).coefficients as *const _
                        as usize
                },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(coefficients)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionProperties>())).gain as *const _ as usize
                },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionProperties),
                    "::",
                    stringify!(gain)
                )
            );
        }
        /// Late reverberation properties of an acoustic environment.
        /// Note that this struct is C-compatible by design to be used across external
        /// C/C++ and C# implementations.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReverbProperties {
            /// RT60's of the reverberation tail at different octave band centre
            /// /// frequencies in seconds.
            pub rt60_values: [f32; 9usize],
            /// Reverb gain.
            pub gain: f32,
        }
        #[test]
        fn bindgen_test_layout_ReverbProperties() {
            assert_eq!(
                ::std::mem::size_of::<ReverbProperties>(),
                40usize,
                concat!("Size of: ", stringify!(ReverbProperties))
            );
            assert_eq!(
                ::std::mem::align_of::<ReverbProperties>(),
                4usize,
                concat!("Alignment of ", stringify!(ReverbProperties))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbProperties>())).rt60_values as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbProperties),
                    "::",
                    stringify!(rt60_values)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ReverbProperties>())).gain as *const _ as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbProperties),
                    "::",
                    stringify!(gain)
                )
            );
        }
        extern "C" {
            /// @param num_channels Number of channels of audio output.
            /// @param frames_per_buffer Number of frames per buffer.
            /// @param sample_rate_hz System sample rate.
            pub fn CreateResonanceAudioApi(
                num_channels: usize,
                frames_per_buffer: usize,
                sample_rate_hz: ::std::os::raw::c_int,
            ) -> *mut root::vraudio::ResonanceAudioApi;
        }
        #[repr(C)]
        pub struct ResonanceAudioApi__bindgen_vtable(::std::os::raw::c_void);
        /// The ResonanceAudioApi library renders high-quality spatial audio. It provides
        /// methods to binaurally render virtual sound sources with simulated room
        /// acoustics. In addition, it supports decoding and binaural rendering of
        /// ambisonic soundfields. Its implementation is single-threaded, thread-safe
        /// and non-blocking to be able to process raw PCM audio buffers directly on the
        /// audio thread while receiving parameter updates from the main/render thread.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ResonanceAudioApi {
            pub vtable_: *const ResonanceAudioApi__bindgen_vtable,
        }
        /// Sound object / ambisonic source identifier.
        pub type ResonanceAudioApi_SourceId = ::std::os::raw::c_int;
        pub const ResonanceAudioApi_kInvalidSourceId: root::vraudio::ResonanceAudioApi_SourceId =
            -1;
        #[test]
        fn bindgen_test_layout_ResonanceAudioApi() {
            assert_eq!(
                ::std::mem::size_of::<ResonanceAudioApi>(),
                8usize,
                concat!("Size of: ", stringify!(ResonanceAudioApi))
            );
            assert_eq!(
                ::std::mem::align_of::<ResonanceAudioApi>(),
                8usize,
                concat!("Alignment of ", stringify!(ResonanceAudioApi))
            );
        }
        extern "C" {
            /// @param pointer Pointer to check.
            /// @return True if the pointer is correctly aligned.
            #[link_name = "\u{1}?IsAligned@vraudio@@YA_NPEBM@Z"]
            pub fn IsAligned(pointer: *const f32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsAligned@vraudio@@YA_NPEBF@Z"]
            pub fn IsAligned1(pointer: *const i16) -> bool;
        }
        extern "C" {
            /// @param length Number of samples before the desired offset pointer.
            /// @param type_size_bytes Size of the type of each entry in the array.
            /// @param memory_alignment_bytes Number of bytes to which an address is aligned.
            /// @return Number of samples into the memory chunk to ensure aligned memory.
            #[link_name = "\u{1}?FindNextAlignedArrayIndex@vraudio@@YA_K_K00@Z"]
            pub fn FindNextAlignedArrayIndex(
                length: usize,
                type_size_bytes: usize,
                memory_alignment_bytes: usize,
            ) -> usize;
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input_a Pointer to the first float in input_a array.
            /// @param input_b Pointer to the first float in input_b array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?AddPointwise@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn AddPointwise(
                length: usize,
                input_a: *const f32,
                input_b: *const f32,
                output: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input Pointer to the first float in input_a array.
            /// @param output Pointer to the first float in input_b array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?SubtractPointwise@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn SubtractPointwise(
                length: usize,
                input_a: *const f32,
                input_b: *const f32,
                output: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input Pointer to the first float in input_a array.
            /// @param input Pointer to the first float in input_b array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?MultiplyPointwise@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn MultiplyPointwise(
                length: usize,
                input_a: *const f32,
                input_b: *const f32,
                output: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input_a Pointer to the first float in input_a array.
            /// @param input_b Pointer to the first float in input_b array.
            /// @param accumulator Pointer to the first float in accumulator array.
            #[link_name = "\u{1}?MultiplyAndAccumulatePointwise@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn MultiplyAndAccumulatePointwise(
                length: usize,
                input_a: *const f32,
                input_b: *const f32,
                accumulator: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param gain Scalar value with which to multiply the input.
            /// @param input Pointer to the first float in input array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?ScalarMultiply@vraudio@@YAX_KMPEBMPEAM@Z"]
            pub fn ScalarMultiply(length: usize, gain: f32, input: *const f32, output: *mut f32);
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param gain Scalar value with which to multiply the input.
            /// @param input Pointer to the first float in input array.
            /// @param output Pointer to the first float in accumulator array.
            #[link_name = "\u{1}?ScalarMultiplyAndAccumulate@vraudio@@YAX_KMPEBMPEAM@Z"]
            pub fn ScalarMultiplyAndAccumulate(
                length: usize,
                gain: f32,
                input: *const f32,
                accumulator: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input Pointer to the first float in input array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?ReciprocalSqrt@vraudio@@YAX_KPEBMPEAM@Z"]
            pub fn ReciprocalSqrt(length: usize, input: *const f32, output: *mut f32);
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param input Pointer to the first float in input array.
            /// @param output Pointer to the first float in output array.
            #[link_name = "\u{1}?Sqrt@vraudio@@YAX_KPEBMPEAM@Z"]
            pub fn Sqrt(length: usize, input: *const f32, output: *mut f32);
        }
        extern "C" {
            /// @param length Number of complex numbers in the input array,
            /// (i.e. half its length).
            /// @param input Pointer to the first float in input array. Length: 2 * |length|.
            /// @param output Pointer to the first float in output array, Length: |length|.
            #[link_name = "\u{1}?ApproxComplexMagnitude@vraudio@@YAX_KPEBMPEAM@Z"]
            pub fn ApproxComplexMagnitude(length: usize, input: *const f32, output: *mut f32);
        }
        extern "C" {
            /// @param length Number of total entries (real & imaginary) in the input array.
            /// @param magnitude Pointer to the first float in the magnitude array, Length:
            /// |length| /  2
            /// @param cos_phase Pointer to the first float in the cosine phase array,
            /// Length: |length| /  2
            /// @param sin_phase Pointer to the first float in the sine phase array, Length:
            /// |length| /  2
            /// @param complex_interleaved_format_output Pointer to the first float in the
            /// output array. Length: |length|.
            #[link_name = "\u{1}?ComplexInterleavedFormatFromMagnitudeAndSinCosPhase@vraudio@@YAX_KPEBM11PEAM@Z"]
            pub fn ComplexInterleavedFormatFromMagnitudeAndSinCosPhase(
                length: usize,
                magnitude: *const f32,
                cos_phase: *const f32,
                sin_phase: *const f32,
                complex_interleaved_format_output: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param mono Pointer to the first float in an input mono array.
            /// @param left Pointer to the first float in the left output array.
            /// @param right Pointer to the first float in the right output array.
            #[link_name = "\u{1}?StereoFromMonoSimd@vraudio@@YAX_KPEBMPEAM2@Z"]
            pub fn StereoFromMonoSimd(
                length: usize,
                mono: *const f32,
                left: *mut f32,
                right: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats.
            /// @param left Pointer to the first float in the left input array.
            /// @param right Pointer to the first float in the right input array.
            /// @param mono Pointer to the first float in an output mono array.
            #[link_name = "\u{1}?MonoFromStereoSimd@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn MonoFromStereoSimd(
                length: usize,
                left: *const f32,
                right: *const f32,
                mono: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of floats in the input array and int16_ts in the output.
            /// @param input Float array.
            /// @param output Int array.
            #[link_name = "\u{1}?Int16FromFloat@vraudio@@YAX_KPEBMPEAF@Z"]
            pub fn Int16FromFloat(length: usize, input: *const f32, output: *mut i16);
        }
        extern "C" {
            /// @param length Number of int16_ts in the input array and floats in the output.
            /// @param input Int array.
            /// @param output Float array.
            #[link_name = "\u{1}?FloatFromInt16@vraudio@@YAX_KPEBFPEAM@Z"]
            pub fn FloatFromInt16(length: usize, input: *const i16, output: *mut f32);
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param channel_0 Input buffer of mono data for the first channel.
            /// @param channel_1 Input buffer of mono data for the second channel.
            /// @param interleaved_buffer Output buffer of stereo interleaved data.
            #[link_name = "\u{1}?InterleaveStereo@vraudio@@YAX_KPEBF1PEAF@Z"]
            pub fn InterleaveStereo(
                length: usize,
                channel_0: *const i16,
                channel_1: *const i16,
                interleaved_buffer: *mut i16,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param channel_0 Input buffer of mono data for the first channel.
            /// @param channel_1 Input buffer of mono data for the second channel.
            /// @param interleaved_buffer Output buffer of stereo interleaved data.
            #[link_name = "\u{1}?InterleaveStereo@vraudio@@YAX_KPEBM1PEAM@Z"]
            pub fn InterleaveStereo1(
                length: usize,
                channel_0: *const f32,
                channel_1: *const f32,
                interleaved_buffer: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param channel_0 Input buffer of mono data for the first channel (float).
            /// @param channel_1 Input buffer of mono data for the second channel (float).
            /// @param interleaved_buffer Output buffer of stereo interleaved data (int16_t).
            #[link_name = "\u{1}?InterleaveStereo@vraudio@@YAX_KPEBM1PEAF@Z"]
            pub fn InterleaveStereo2(
                length: usize,
                channel_0: *const f32,
                channel_1: *const f32,
                interleaved_buffer: *mut i16,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param interleaved_buffer Input buffer of stereo interleaved data.
            /// @param channel_0 Output buffer of mono data for the first channel.
            /// @param channel_1 Output buffer of mono data for the second channel.
            #[link_name = "\u{1}?DeinterleaveStereo@vraudio@@YAX_KPEBFPEAF2@Z"]
            pub fn DeinterleaveStereo(
                length: usize,
                interleaved_buffer: *const i16,
                channel_0: *mut i16,
                channel_1: *mut i16,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param interleaved_buffer Input buffer of stereo interleaved data.
            /// @param channel_0 Output buffer of mono data for the first channel.
            /// @param channel_1 Output buffer of mono data for the second channel.
            #[link_name = "\u{1}?DeinterleaveStereo@vraudio@@YAX_KPEBMPEAM2@Z"]
            pub fn DeinterleaveStereo1(
                length: usize,
                interleaved_buffer: *const f32,
                channel_0: *mut f32,
                channel_1: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be twice this size.
            /// @param interleaved_buffer Input buffer of stereo interleaved data (int16_t).
            /// @param channel_0 Output buffer of mono data for the first channel (float).
            /// @param channel_1 Output buffer of mono data for the second channel (float).
            #[link_name = "\u{1}?DeinterleaveStereo@vraudio@@YAX_KPEBFPEAM2@Z"]
            pub fn DeinterleaveStereo2(
                length: usize,
                interleaved_buffer: *const i16,
                channel_0: *mut f32,
                channel_1: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be four times this size and the workspace must be five times this size.
            /// @param channel_0 Input buffer of mono data for the first channel.
            /// @param channel_1 Input buffer of mono data for the second channel.
            /// @param channel_2 Input buffer of mono data for the third channel.
            /// @param channel_3 Input buffer of mono data for the fourth channel.
            /// @param workspace Aligned buffer of 5 * |length| samples in length.
            /// @param interleaved_buffer Output buffer of quad interleaved data.
            #[link_name = "\u{1}?InterleaveQuad@vraudio@@YAX_KPEBF111PEAF2@Z"]
            pub fn InterleaveQuad(
                length: usize,
                channel_0: *const i16,
                channel_1: *const i16,
                channel_2: *const i16,
                channel_3: *const i16,
                workspace: *mut i16,
                interleaved_buffer: *mut i16,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be four times this size and the workspace must be five times this size.
            /// @param channel_0 Input buffer of mono data for the first channel.
            /// @param channel_1 Input buffer of mono data for the second channel.
            /// @param channel_2 Input buffer of mono data for the third channel.
            /// @param channel_3 Input buffer of mono data for the fourth channel.
            /// @param workspace Aligned buffer of 5 * |length| samples in length.
            /// @param interleaved_buffer Output buffer of quad interleaved data.
            #[link_name = "\u{1}?InterleaveQuad@vraudio@@YAX_KPEBM111PEAM2@Z"]
            pub fn InterleaveQuad1(
                length: usize,
                channel_0: *const f32,
                channel_1: *const f32,
                channel_2: *const f32,
                channel_3: *const f32,
                workspace: *mut f32,
                interleaved_buffer: *mut f32,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be four times this size and the workspace must be five times this size.
            /// @param interleaved_buffer Input buffer of quad interleaved data.
            /// @param workspace Aligned buffer of 5 * |length| samples in length.
            /// @param channel_0 Output buffer of mono data for the first channel.
            /// @param channel_1 Output buffer of mono data for the second channel.
            /// @param channel_2 Output buffer of mono data for the third channel.
            /// @param channel_3 Output buffer of mono data for the fourth channel.
            #[link_name = "\u{1}?DeinterleaveQuad@vraudio@@YAX_KPEBFPEAF2222@Z"]
            pub fn DeinterleaveQuad(
                length: usize,
                interleaved_buffer: *const i16,
                workspace: *mut i16,
                channel_0: *mut i16,
                channel_1: *mut i16,
                channel_2: *mut i16,
                channel_3: *mut i16,
            );
        }
        extern "C" {
            /// @param length Number of frames per mono channel. The interleaved buffer must
            /// be four times this size and the workspace must be five times this size.
            /// @param interleaved_buffer Input buffer of quad interleaved data.
            /// @param workspace Aligned buffer of 5 * |length| samples in length.
            /// @param channel_0 Output buffer of mono data for the first channel.
            /// @param channel_1 Output buffer of mono data for the second channel.
            /// @param channel_2 Output buffer of mono data for the third channel.
            /// @param channel_3 Output buffer of mono data for the fourth channel.
            #[link_name = "\u{1}?DeinterleaveQuad@vraudio@@YAX_KPEBMPEAM2222@Z"]
            pub fn DeinterleaveQuad1(
                length: usize,
                interleaved_buffer: *const f32,
                workspace: *mut f32,
                channel_0: *mut f32,
                channel_1: *mut f32,
                channel_2: *mut f32,
                channel_3: *mut f32,
            );
        }
        pub type AlignedAllocator_Pointer = u8;
        pub type AlignedAllocator_ConstPointer = u8;
        pub type AlignedAllocator_SizeType = u8;
        /// Rebind is used to allocate container internal variables of type |U|
        /// /// (which don't need to be aligned).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct AlignedAllocator_rebind {
            pub _address: u8,
        }
        pub type AlignedAllocator_rebind_other = u8;
        /// Provides an interface to a single audio channel in |AudioBuffer|. Note that a
        /// |ChannelView| instance does not own the data it is initialized with.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ChannelView {
            /// Iterator of first and last element in channel.
            pub begin_itr_: *mut f32,
            /// Channel size.
            pub size_: usize,
            /// Flag indicating if the channel is enabled.
            pub enabled_: bool,
        }
        #[test]
        fn bindgen_test_layout_ChannelView() {
            assert_eq!(
                ::std::mem::size_of::<ChannelView>(),
                24usize,
                concat!("Size of: ", stringify!(ChannelView))
            );
            assert_eq!(
                ::std::mem::align_of::<ChannelView>(),
                8usize,
                concat!("Alignment of ", stringify!(ChannelView))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ChannelView>())).begin_itr_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelView),
                    "::",
                    stringify!(begin_itr_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ChannelView>())).size_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelView),
                    "::",
                    stringify!(size_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ChannelView>())).enabled_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelView),
                    "::",
                    stringify!(enabled_)
                )
            );
        }
        /// Sound object / ambisonic source identifier.
        pub type SourceId = ::std::os::raw::c_int;
        pub const kInvalidSourceId: root::vraudio::SourceId = -1;
        pub const kMemoryAlignmentBytes: usize = 64;
        pub const kMaxSupportedAmbisonicOrder: ::std::os::raw::c_int = 3;
        pub const kMaxSupportedNumFrames: usize = 16384;
        pub const kNumMonoChannels: usize = 1;
        pub const kNumStereoChannels: usize = 2;
        pub const kNumSurroundFiveDotOneChannels: usize = 6;
        pub const kNumSurroundSevenDotOneChannels: usize = 8;
        pub const kNumFirstOrderAmbisonicChannels: usize = 4;
        pub const kNumSecondOrderAmbisonicChannels: usize = 9;
        pub const kNumThirdOrderAmbisonicChannels: usize = 16;
        pub const kNumFirstOrderAmbisonicWithNonDiegeticStereoChannels: usize = 6;
        pub const kNumSecondOrderAmbisonicWithNonDiegeticStereoChannels: usize = 11;
        pub const kNumThirdOrderAmbisonicWithNonDiegeticStereoChannels: usize = 18;
        pub const kNegative60dbInAmplitude: f32 = 0.0010000000474974513;
        pub const kEpsilonDouble: f64 = 0.000001;
        pub const kEpsilonFloat: f32 = 0.0000009999999974752427;
        extern "C" {
            #[link_name = "\u{1}?kInverseSqrtTwo@vraudio@@3MB"]
            pub static mut kInverseSqrtTwo: f32;
        }
        extern "C" {
            #[link_name = "\u{1}?kSqrtTwo@vraudio@@3MB"]
            pub static mut kSqrtTwo: f32;
        }
        extern "C" {
            #[link_name = "\u{1}?kSqrtThree@vraudio@@3MB"]
            pub static mut kSqrtThree: f32;
        }
        pub const kPi: f32 = 3.1415927410125732;
        pub const kHalfPi: f32 = 1.5707963705062866;
        pub const kTwoPi: f32 = 6.2831854820251465;
        pub const kRadiansFromDegrees: f32 = 0.01745329238474369;
        pub const kDegreesFromRadians: f32 = 57.295780181884766;
        extern "C" {
            #[link_name = "\u{1}?kNegativeLog1000@vraudio@@3MB"]
            pub static mut kNegativeLog1000: f32;
        }
        pub const kLowestOctaveBandHz: f32 = 31.25;
        pub const kNumReverbOctaveBands: usize = 9;
        extern "C" {
            #[link_name = "\u{1}?kOctaveBandCentres@vraudio@@3QBMB"]
            pub static mut kOctaveBandCentres: [f32; 9usize];
        }
        pub const kNumRoomSurfaces: usize = 6;
        pub const kSpeedOfSound: f32 = 343.0;
        pub const kStereoLeftDegrees: f32 = 90.0;
        pub const kStereoRightDegrees: f32 = -90.0;
        pub const kMillisecondsFromSeconds: f32 = 1000.0;
        pub const kSecondsFromMilliseconds: f32 = 0.0010000000474974513;
        pub const kMicrosecondsFromSeconds: f64 = 1000000.0;
        pub const kSecondsFromMicroseconds: f64 = 0.000001;
        pub const kNearFieldThreshold: f32 = 1.0;
        pub const kMinNearFieldDistance: f32 = 0.10000000149011612;
        pub const kMaxNearFieldEffectGain: f32 = 9.0;
        pub const kUnitRampLength: usize = 2048;
        pub const kRotationQuantizationRad: f32 = 0.01745329238474369;
        /// Note do *NOT* use double array subscripts to iterate over multiple samples
        /// since it performs a channel iterator lookup for every sample:
        /// for (size_t c=0; c < audio_buffer.num_channels(); ++c) {
        /// for (size_t i = 0; i < channel.size(); ++i) {
        /// audio_buffer[c][i] *= gain;  /// *BAD*
        /// }
        /// }
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct AudioBuffer {
            /// Number of frames per buffer.
            pub num_frames_: usize,
            /// Audio buffer that sequentially stores multiple audio channels in a planar
            /// /// format.
            pub data_: root::vraudio::AudioBuffer_AlignedFloatVector,
            /// Size of audio buffer.
            pub data_size_: usize,
            /// Vector of |AudioBuffer::Channel|s.
            pub channel_views_: [u64; 3usize],
            /// Id of a source that this buffer belongs to.
            pub source_id_: root::vraudio::SourceId,
        }
        /// View on separate audio channel.
        pub type AudioBuffer_Channel = root::vraudio::ChannelView;
        /// Allocator class to allocate aligned floats.
        pub type AudioBuffer_FloatAllocator = u8;
        /// Allocator class to allocate aligned int16s.
        pub type AudioBuffer_Int16Allocator = u8;
        /// AlignedFloatBuffer for storing audio data.
        pub type AudioBuffer_AlignedFloatVector = [u64; 3usize];
        /// AlignedInt16Buffer for storing audio data.
        pub type AudioBuffer_AlignedInt16Vector = u8;
        #[test]
        fn bindgen_test_layout_AudioBuffer() {
            assert_eq!(
                ::std::mem::size_of::<AudioBuffer>(),
                72usize,
                concat!("Size of: ", stringify!(AudioBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<AudioBuffer>(),
                8usize,
                concat!("Alignment of ", stringify!(AudioBuffer))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AudioBuffer>())).num_frames_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AudioBuffer),
                    "::",
                    stringify!(num_frames_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AudioBuffer>())).data_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AudioBuffer),
                    "::",
                    stringify!(data_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AudioBuffer>())).data_size_ as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AudioBuffer),
                    "::",
                    stringify!(data_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AudioBuffer>())).channel_views_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AudioBuffer),
                    "::",
                    stringify!(channel_views_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AudioBuffer>())).source_id_ as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AudioBuffer),
                    "::",
                    stringify!(source_id_)
                )
            );
        }
        extern "C" {
            /// Default constructor initializes an empty |AudioBuffer|.
            #[link_name = "\u{1}??0AudioBuffer@vraudio@@QEAA@XZ"]
            pub fn AudioBuffer_AudioBuffer(this: *mut root::vraudio::AudioBuffer);
        }
        extern "C" {
            /// Constructor.
            /// ///
            /// /// @param num_channels Number of channels.
            /// /// @param num_frames Number of frames.
            #[link_name = "\u{1}??0AudioBuffer@vraudio@@QEAA@_K0@Z"]
            pub fn AudioBuffer_AudioBuffer1(
                this: *mut root::vraudio::AudioBuffer,
                num_channels: usize,
                num_frames: usize,
            );
        }
        extern "C" {
            /// Move constructor.
            #[link_name = "\u{1}??0AudioBuffer@vraudio@@QEAA@$$QEAV01@@Z"]
            pub fn AudioBuffer_AudioBuffer2(
                this: *mut root::vraudio::AudioBuffer,
                other: *mut root::vraudio::AudioBuffer,
            );
        }
        impl AudioBuffer {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AudioBuffer_AudioBuffer(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(num_channels: usize, num_frames: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AudioBuffer_AudioBuffer1(&mut __bindgen_tmp, num_channels, num_frames);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(other: *mut root::vraudio::AudioBuffer) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AudioBuffer_AudioBuffer2(&mut __bindgen_tmp, other);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq)]
        pub struct WorldPosition {
            pub _base: [u32; 3usize],
        }
        #[test]
        fn bindgen_test_layout_WorldPosition() {
            assert_eq!(
                ::std::mem::size_of::<WorldPosition>(),
                12usize,
                concat!("Size of: ", stringify!(WorldPosition))
            );
            assert_eq!(
                ::std::mem::align_of::<WorldPosition>(),
                4usize,
                concat!("Alignment of ", stringify!(WorldPosition))
            );
        }
        extern "C" {
            /// Constructs a zero vector.
            #[link_name = "\u{1}??0WorldPosition@vraudio@@QEAA@XZ"]
            pub fn WorldPosition_WorldPosition(this: *mut root::vraudio::WorldPosition);
        }
        impl WorldPosition {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                WorldPosition_WorldPosition(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq)]
        pub struct WorldRotation {
            pub _base: [u32; 4usize],
        }
        #[test]
        fn bindgen_test_layout_WorldRotation() {
            assert_eq!(
                ::std::mem::size_of::<WorldRotation>(),
                16usize,
                concat!("Size of: ", stringify!(WorldRotation))
            );
            assert_eq!(
                ::std::mem::align_of::<WorldRotation>(),
                4usize,
                concat!("Alignment of ", stringify!(WorldRotation))
            );
        }
        extern "C" {
            /// Constructs an identity rotation.
            #[link_name = "\u{1}??0WorldRotation@vraudio@@QEAA@XZ"]
            pub fn WorldRotation_WorldRotation(this: *mut root::vraudio::WorldRotation);
        }
        impl WorldRotation {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                WorldRotation_WorldRotation(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        pub type AngleAxisf = root::Eigen::AngleAxis<f32>;
        pub type AudioPosition = root::vraudio::WorldPosition;
        pub type AudioRotation = root::vraudio::WorldRotation;
        extern "C" {
            /// @param x_array Array of the x coordinates of the points.
            /// @param y_array Array of the y coordinates of the points.
            /// @param slope Output slope of the fitted line.
            /// @param intercept Output slope of the fitted line.
            /// @param r_squared Coefficient of determination.
            /// @return False if the fitting fails.
            #[link_name = "\u{1}?LinearLeastSquareFitting@vraudio@@YA_NAEBV?$vector@MV?$allocator@M@std@@@std@@0PEAM11@Z"]
            pub fn LinearLeastSquareFitting(
                x_array: *const [u64; 3usize],
                y_array: *const [u64; 3usize],
                slope: *mut f32,
                intercept: *mut f32,
                r_squared: *mut f32,
            ) -> bool;
        }
        /// Represents angular position on a sphere in terms of azimuth and elevation.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SphericalAngle {
            pub azimuth_: f32,
            pub elevation_: f32,
        }
        #[test]
        fn bindgen_test_layout_SphericalAngle() {
            assert_eq!(
                ::std::mem::size_of::<SphericalAngle>(),
                8usize,
                concat!("Size of: ", stringify!(SphericalAngle))
            );
            assert_eq!(
                ::std::mem::align_of::<SphericalAngle>(),
                4usize,
                concat!("Alignment of ", stringify!(SphericalAngle))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SphericalAngle>())).azimuth_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SphericalAngle),
                    "::",
                    stringify!(azimuth_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SphericalAngle>())).elevation_ as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SphericalAngle),
                    "::",
                    stringify!(elevation_)
                )
            );
        }
        extern "C" {
            /// Returns a spherical angle representation of given |world_position| (World
            /// /// Space).
            /// ///
            /// /// @param world_position 3D position in world space.
            /// /// @return Spherical angle that represents the |world_position|.
            #[link_name = "\u{1}?FromWorldPosition@SphericalAngle@vraudio@@SA?AV12@AEBVWorldPosition@2@@Z"]
            pub fn SphericalAngle_FromWorldPosition(
                world_position: *const root::vraudio::WorldPosition,
            ) -> root::vraudio::SphericalAngle;
        }
        extern "C" {
            /// Returns a spherical angle from azimuth and elevation in degrees.
            #[link_name = "\u{1}?FromDegrees@SphericalAngle@vraudio@@SA?AV12@MM@Z"]
            pub fn SphericalAngle_FromDegrees(
                azimuth_degrees: f32,
                elevation_degrees: f32,
            ) -> root::vraudio::SphericalAngle;
        }
        extern "C" {
            /// Returns another spherical angle with the same elevation but the azimuth
            /// /// sign flipped.
            /// ///
            /// /// @return Horizontally flipped version of the spherical angle.
            #[link_name = "\u{1}?FlipAzimuth@SphericalAngle@vraudio@@QEBA?AV12@XZ"]
            pub fn SphericalAngle_FlipAzimuth(
                this: *const root::vraudio::SphericalAngle,
            ) -> root::vraudio::SphericalAngle;
        }
        extern "C" {
            /// Returns the |WorldPosition| coordinates (World Space) on the unit sphere
            /// /// corresponding to this spherical angle. The transformation is
            /// /// defined as such:
            /// /// x = -cos(elevation) * sin(azimuth)
            /// /// y = sin(elevation)
            /// /// z = -cos(elevation) * cos(azimuth)
            /// ///
            /// /// @return 3D position in world space.
            #[link_name = "\u{1}?GetWorldPositionOnUnitSphere@SphericalAngle@vraudio@@QEBA?AVWorldPosition@2@XZ"]
            pub fn SphericalAngle_GetWorldPositionOnUnitSphere(
                this: *const root::vraudio::SphericalAngle,
            ) -> root::vraudio::WorldPosition;
        }
        extern "C" {
            /// Returns the rotated version of the spherical angle using given
            /// /// |WorldRotation|.
            /// ///
            /// /// @param rotation Rotation to be applied to the spherical angle.
            /// /// @return Rotated version of the spherical angle.
            #[link_name = "\u{1}?Rotate@SphericalAngle@vraudio@@QEBA?AV12@AEBVWorldRotation@2@@Z"]
            pub fn SphericalAngle_Rotate(
                this: *const root::vraudio::SphericalAngle,
                rotation: *const root::vraudio::WorldRotation,
            ) -> root::vraudio::SphericalAngle;
        }
        extern "C" {
            /// Constructs a spherical angle with the given azimuth and elevation.
            #[link_name = "\u{1}??0SphericalAngle@vraudio@@QEAA@MM@Z"]
            pub fn SphericalAngle_SphericalAngle(
                this: *mut root::vraudio::SphericalAngle,
                azimuth: f32,
                elevation: f32,
            );
        }
        extern "C" {
            /// Constructs a default spherical angle (azimuth = 0, elevation = 0).
            #[link_name = "\u{1}??0SphericalAngle@vraudio@@QEAA@XZ"]
            pub fn SphericalAngle_SphericalAngle1(this: *mut root::vraudio::SphericalAngle);
        }
        extern "C" {
            /// Constructs a spherical angle from a given one.
            #[link_name = "\u{1}??0SphericalAngle@vraudio@@QEAA@AEBV01@@Z"]
            pub fn SphericalAngle_SphericalAngle2(
                this: *mut root::vraudio::SphericalAngle,
                other: *const root::vraudio::SphericalAngle,
            );
        }
        impl SphericalAngle {
            #[inline]
            pub unsafe fn FromWorldPosition(
                world_position: *const root::vraudio::WorldPosition,
            ) -> root::vraudio::SphericalAngle {
                SphericalAngle_FromWorldPosition(world_position)
            }
            #[inline]
            pub unsafe fn FromDegrees(
                azimuth_degrees: f32,
                elevation_degrees: f32,
            ) -> root::vraudio::SphericalAngle {
                SphericalAngle_FromDegrees(azimuth_degrees, elevation_degrees)
            }
            #[inline]
            pub unsafe fn FlipAzimuth(&self) -> root::vraudio::SphericalAngle {
                SphericalAngle_FlipAzimuth(self)
            }
            #[inline]
            pub unsafe fn GetWorldPositionOnUnitSphere(&self) -> root::vraudio::WorldPosition {
                SphericalAngle_GetWorldPositionOnUnitSphere(self)
            }
            #[inline]
            pub unsafe fn Rotate(
                &self,
                rotation: *const root::vraudio::WorldRotation,
            ) -> root::vraudio::SphericalAngle {
                SphericalAngle_Rotate(self, rotation)
            }
            #[inline]
            pub unsafe fn new(azimuth: f32, elevation: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SphericalAngle_SphericalAngle(&mut __bindgen_tmp, azimuth, elevation);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SphericalAngle_SphericalAngle1(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(other: *const root::vraudio::SphericalAngle) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SphericalAngle_SphericalAngle2(&mut __bindgen_tmp, other);
                __bindgen_tmp
            }
        }
        /// Represents a lookup table for encoding of Ambisonic periphonic sound fields.
        /// Supports arbitrary Ambisonic order and uses AmbiX convention (ACN channel
        /// sequencing, SN3D normalization).
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct AmbisonicLookupTable {
            /// Ambisonic order.
            pub max_ambisonic_order_: ::std::os::raw::c_int,
            /// Maximum number of coefficients to be stored in the lookup table equal to
            /// /// the number of Ambisonic channels for |max_ambisonic_order_| - 1. This is
            /// /// because we do not need to store the coefficient for the first spherical
            /// /// harmonic coefficient as it is always 1.
            pub max_num_coeffs_in_table_: usize,
            /// Lookup table for storing Ambisonic encoding coefficients for one quadrant
            /// /// of the sphere.
            pub encoder_table_: [u64; 3usize],
            /// Lookup table for storing information about spherical harmonic symmetries.
            pub symmetries_table_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_AmbisonicLookupTable() {
            assert_eq!(
                ::std::mem::size_of::<AmbisonicLookupTable>(),
                64usize,
                concat!("Size of: ", stringify!(AmbisonicLookupTable))
            );
            assert_eq!(
                ::std::mem::align_of::<AmbisonicLookupTable>(),
                8usize,
                concat!("Alignment of ", stringify!(AmbisonicLookupTable))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicLookupTable>())).max_ambisonic_order_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicLookupTable),
                    "::",
                    stringify!(max_ambisonic_order_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicLookupTable>())).max_num_coeffs_in_table_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicLookupTable),
                    "::",
                    stringify!(max_num_coeffs_in_table_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicLookupTable>())).encoder_table_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicLookupTable),
                    "::",
                    stringify!(encoder_table_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicLookupTable>())).symmetries_table_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicLookupTable),
                    "::",
                    stringify!(symmetries_table_)
                )
            );
        }
        extern "C" {
            /// Gets spherical harmonic encoding coefficients for a given order and
            /// /// writes them to |encoding_coeffs|.
            /// ///
            /// /// @param ambisonic_order Ambisonic order of the encoded sound source.
            /// /// @param source_direction Direction of a sound source in spherical
            /// ///     coordinates.
            /// /// @param source_spread_deg Encoded sound source angular spread in degrees.
            /// /// @param encoding_coeffs Pointer to a vector of Ambisonic encoding
            /// ///     coefficients.
            #[link_name = "\u{1}?GetEncodingCoeffs@AmbisonicLookupTable@vraudio@@QEBAXHAEBVSphericalAngle@2@MPEAV?$vector@MV?$allocator@M@std@@@std@@@Z"]
            pub fn AmbisonicLookupTable_GetEncodingCoeffs(
                this: *const root::vraudio::AmbisonicLookupTable,
                ambisonic_order: ::std::os::raw::c_int,
                source_direction: *const root::vraudio::SphericalAngle,
                source_spread_deg: f32,
                encoding_coeffs: *mut [u64; 3usize],
            );
        }
        extern "C" {
            /// Creates Ambisonic (AmbiX) encoder lookup table given the
            /// /// |max_ambisonic_order| used by the client. AmbiX convention uses ACN channel
            /// /// sequencing and SN3D normalization.
            #[link_name = "\u{1}??0AmbisonicLookupTable@vraudio@@QEAA@H@Z"]
            pub fn AmbisonicLookupTable_AmbisonicLookupTable(
                this: *mut root::vraudio::AmbisonicLookupTable,
                max_ambisonic_order: ::std::os::raw::c_int,
            );
        }
        impl AmbisonicLookupTable {
            #[inline]
            pub unsafe fn GetEncodingCoeffs(
                &self,
                ambisonic_order: ::std::os::raw::c_int,
                source_direction: *const root::vraudio::SphericalAngle,
                source_spread_deg: f32,
                encoding_coeffs: *mut [u64; 3usize],
            ) {
                AmbisonicLookupTable_GetEncodingCoeffs(
                    self,
                    ambisonic_order,
                    source_direction,
                    source_spread_deg,
                    encoding_coeffs,
                )
            }
            #[inline]
            pub unsafe fn new(max_ambisonic_order: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AmbisonicLookupTable_AmbisonicLookupTable(&mut __bindgen_tmp, max_ambisonic_order);
                __bindgen_tmp
            }
        }
        /// Configuration of the GraphManager and the nodes it is instantiating.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct GraphManagerConfig {
            /// Configuration name.
            pub configuration_name: root::std::string,
            /// Maximum ambisonic order allowed.
            pub max_ambisonic_order: ::std::os::raw::c_int,
            /// HRIR filenames (second element) per ambisonic order (first element).
            pub sh_hrir_filenames: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_GraphManagerConfig() {
            assert_eq!(
                ::std::mem::size_of::<GraphManagerConfig>(),
                64usize,
                concat!("Size of: ", stringify!(GraphManagerConfig))
            );
            assert_eq!(
                ::std::mem::align_of::<GraphManagerConfig>(),
                8usize,
                concat!("Alignment of ", stringify!(GraphManagerConfig))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManagerConfig>())).configuration_name as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManagerConfig),
                    "::",
                    stringify!(configuration_name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManagerConfig>())).max_ambisonic_order as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManagerConfig),
                    "::",
                    stringify!(max_ambisonic_order)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManagerConfig>())).sh_hrir_filenames as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManagerConfig),
                    "::",
                    stringify!(sh_hrir_filenames)
                )
            );
        }
        /// This class wraps the pffft library and enables reall FFT transformations to
        /// be performed on aligned float buffers of data. The class also manages all
        /// necessary data buffers and zero padding. This class is not thread safe.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FftManager {
            /// FFT size in samples.
            pub fft_size_: usize,
            /// Number of frames in each buffer of input data.
            pub frames_per_buffer_: usize,
            /// Inverse scale to be applied to buffers transformed from frequency to time
            /// /// domain.
            pub inverse_fft_scale_: f32,
            /// Temporary time domain buffer to store zeropadded input.
            pub temp_zeropad_buffer_: root::vraudio::AudioBuffer,
            /// Temporary freq domain buffer to store.
            pub temp_freq_buffer_: root::vraudio::AudioBuffer,
            /// pffft states.
            pub fft_: *mut root::PFFFT_Setup,
            /// Workspace for pffft. This pointer should be set to null for |fft_size_|
            /// /// less than 2^14. In which case the stack is used. This is the recommendation
            /// /// by the author of the pffft library.
            pub pffft_workspace_: *mut f32,
        }
        extern "C" {
            #[link_name = "\u{1}?kMinFftSize@FftManager@vraudio@@2_KB"]
            pub static mut FftManager_kMinFftSize: usize;
        }
        #[test]
        fn bindgen_test_layout_FftManager() {
            assert_eq!(
                ::std::mem::size_of::<FftManager>(),
                184usize,
                concat!("Size of: ", stringify!(FftManager))
            );
            assert_eq!(
                ::std::mem::align_of::<FftManager>(),
                8usize,
                concat!("Alignment of ", stringify!(FftManager))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<FftManager>())).fft_size_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(fft_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FftManager>())).frames_per_buffer_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FftManager>())).inverse_fft_scale_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(inverse_fft_scale_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FftManager>())).temp_zeropad_buffer_ as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(temp_zeropad_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FftManager>())).temp_freq_buffer_ as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(temp_freq_buffer_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<FftManager>())).fft_ as *const _ as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(fft_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FftManager>())).pffft_workspace_ as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FftManager),
                    "::",
                    stringify!(pffft_workspace_)
                )
            );
        }
        extern "C" {
            /// Transforms a single channel of time domain input data into a frequency
            /// /// domain representation.
            /// ///
            /// /// @param time_channel Time domain input. If the length is less than
            /// ///     |fft_size_|, the input is zeropadded. The max length is |fft_size_|.
            /// /// @param freq_channel Frequency domain output, |fft_size| samples long.
            #[link_name = "\u{1}?FreqFromTimeDomain@FftManager@vraudio@@QEAAXAEBVChannelView@2@PEAV32@@Z"]
            pub fn FftManager_FreqFromTimeDomain(
                this: *mut root::vraudio::FftManager,
                time_channel: *const root::vraudio::AudioBuffer_Channel,
                freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Transforms a single channel of frequency domain input data into a time
            /// /// domain representation. Note: The input must be in pffft format see:
            /// /// goo.gl/LYbgX7. This method can output to a buffer of either
            /// /// |frames_per_buffer_| or |fft_size_| in length. This feature ensures an
            /// /// additional copy is not needed where this method is to be used with an
            /// /// overlap add.
            /// ///
            /// /// @param freq_channel Frequency domain input, |fft_size| samples long.
            /// /// @param time_channel Time domain output, |frames_per_buffer_| samples long
            /// ///     OR |fft_size_| samples long.
            #[link_name = "\u{1}?TimeFromFreqDomain@FftManager@vraudio@@QEAAXAEBVChannelView@2@PEAV32@@Z"]
            pub fn FftManager_TimeFromFreqDomain(
                this: *mut root::vraudio::FftManager,
                freq_channel: *const root::vraudio::AudioBuffer_Channel,
                time_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Applies a 1/|fft_size_| scaling to time domain output. NOTE this need not
            /// /// be applied where a convolution is taking place as the scaling will be
            /// /// included therein.
            /// ///
            /// /// @param time_channel Time domain data to be scaled.
            #[link_name = "\u{1}?ApplyReverseFftScaling@FftManager@vraudio@@QEAAXPEAVChannelView@2@@Z"]
            pub fn FftManager_ApplyReverseFftScaling(
                this: *mut root::vraudio::FftManager,
                time_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Transforms a pffft frequency domain format buffer into canonical format
            /// /// with alternating real and imaginary values with increasing frequency. The
            /// /// first two entries of |output| are the real part of the DC and Nyquist
            /// /// frequencies (imaginary part is zero). The alternating real and imaginary
            /// /// parts start from the third entry in |output|. For more info on the pffft
            /// /// format see: goo.gl/LYbgX7
            /// ///
            /// /// @param input Frequency domain input channel, |fft_size| samples long.
            /// /// @param output Frequency domain output channel,|fft_size| samples long.
            #[link_name = "\u{1}?GetCanonicalFormatFreqBuffer@FftManager@vraudio@@QEAAXAEBVChannelView@2@PEAV32@@Z"]
            pub fn FftManager_GetCanonicalFormatFreqBuffer(
                this: *mut root::vraudio::FftManager,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Transforms a canonical frequency domain format buffer into pffft format.
            /// /// For more info on the pffft format see: goo.gl/LYbgX7
            /// ///
            /// /// @param input Frequency domain input channel, |fft_size| samples long.
            /// /// @param output Frequency domain output channel, |fft_size| samples long.
            #[link_name = "\u{1}?GetPffftFormatFreqBuffer@FftManager@vraudio@@QEAAXAEBVChannelView@2@PEAV32@@Z"]
            pub fn FftManager_GetPffftFormatFreqBuffer(
                this: *mut root::vraudio::FftManager,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Genarates a buffer containing the single sided magnitude spectrum of a
            /// /// frequency domain buffer. The input must be in Canonical format. The output
            /// /// will have DC frequency as it's first entry and the Nyquist as it's last.
            /// ///
            /// /// @param freq_channel Canonical format frequency domain buffer,
            /// ///     |fft_size_| samples long.
            /// /// @param magnitude_channel Magnitude of the |freq_channel|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            #[link_name = "\u{1}?MagnitudeFromCanonicalFreqBuffer@FftManager@vraudio@@QEAAXAEBVChannelView@2@PEAV32@@Z"]
            pub fn FftManager_MagnitudeFromCanonicalFreqBuffer(
                this: *mut root::vraudio::FftManager,
                freq_channel: *const root::vraudio::AudioBuffer_Channel,
                magnitude_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Combines single sided magnitude and phase spectra into a canonical format
            /// /// frequency domain buffer. The inputs must have DC frequency as their first
            /// /// entry and the Nyquist as their last.
            /// ///
            /// /// @param magnitude_channel Magnitude of the |frequency_buffer|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            /// /// @param phase_channel Phase of the |frequency_buffer|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            /// /// @param canonical_freq_channel Canonical format frequency domain buffer,
            /// ///     |fft_size_| samples long.
            #[link_name = "\u{1}?CanonicalFreqBufferFromMagnitudeAndPhase@FftManager@vraudio@@QEAAXAEBVChannelView@2@0PEAV32@@Z"]
            pub fn FftManager_CanonicalFreqBufferFromMagnitudeAndPhase(
                this: *mut root::vraudio::FftManager,
                magnitude_channel: *const root::vraudio::AudioBuffer_Channel,
                phase_channel: *const root::vraudio::AudioBuffer_Channel,
                canonical_freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Combines single sided magnitude spectrum and the cosine and sine of a phase
            /// /// spectrum into a canonical format frequency domain buffer. The inputs must
            /// /// have DC frequency as their first entry and the Nyquist as their last.
            /// /// The phase spectra channels can be offset by |phase_offset|. This feature
            /// /// is specifically for use as an optimization in the |SpectralReverb|.
            /// ///
            /// /// @param phase_offset An offset into the channels of the phase buffer.
            /// /// @param magnitude_channel Magnitude of the |frequency_buffer|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            /// /// @param sin_phase_channel Sine of the phase of the |frequency_buffer|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            /// /// @param cos_phase_channel Cosine of the phase of the |frequency_buffer|.
            /// ///     |frames_per_buffer_| + 1 samples long.
            /// /// @param canonical_freq_channel Canonical format frequency domain buffer,
            /// ///     |fft_size_| samples long.
            #[link_name = "\u{1}?CanonicalFreqBufferFromMagnitudeAndSinCosPhase@FftManager@vraudio@@QEAAX_KAEBVChannelView@2@11PEAV32@@Z"]
            pub fn FftManager_CanonicalFreqBufferFromMagnitudeAndSinCosPhase(
                this: *mut root::vraudio::FftManager,
                phase_offset: usize,
                magnitude_channel: *const root::vraudio::AudioBuffer_Channel,
                sin_phase_channel: *const root::vraudio::AudioBuffer_Channel,
                cos_phase_channel: *const root::vraudio::AudioBuffer_Channel,
                canonical_freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Performs a pointwise complex multiplication of two frequency domain buffers
            /// /// and applies tha inverse scaling factor of 1/|fft_size_|. This operation is
            /// /// equivalent to a time domain circular convolution.
            /// ///
            /// /// @param input_a Frequency domain input channel, |fft_size| samples long.
            /// /// @param input_b Frequency domain input channel, |fft_size| samples long.
            /// /// @param scaled_output Frequency domain output channel, |fft_size| samples
            /// ///     long.
            #[link_name = "\u{1}?FreqDomainConvolution@FftManager@vraudio@@QEAAXAEBVChannelView@2@0PEAV32@@Z"]
            pub fn FftManager_FreqDomainConvolution(
                this: *mut root::vraudio::FftManager,
                input_a: *const root::vraudio::AudioBuffer_Channel,
                input_b: *const root::vraudio::AudioBuffer_Channel,
                scaled_output: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Constructs a FftManager insatnce. One instance of this class can be shared.
            /// /// This class is not thread safe.
            /// ///
            /// /// @param frames_per_buffer System's number of frames per buffer.
            #[link_name = "\u{1}??0FftManager@vraudio@@QEAA@_K@Z"]
            pub fn FftManager_FftManager(
                this: *mut root::vraudio::FftManager,
                frames_per_buffer: usize,
            );
        }
        extern "C" {
            /// Destroys a FftManager instance freeing associated aligned memory.
            #[link_name = "\u{1}??_DFftManager@vraudio@@QEAAXXZ"]
            pub fn FftManager_FftManager_destructor(this: *mut root::vraudio::FftManager);
        }
        impl FftManager {
            #[inline]
            pub unsafe fn FreqFromTimeDomain(
                &mut self,
                time_channel: *const root::vraudio::AudioBuffer_Channel,
                freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_FreqFromTimeDomain(self, time_channel, freq_channel)
            }
            #[inline]
            pub unsafe fn TimeFromFreqDomain(
                &mut self,
                freq_channel: *const root::vraudio::AudioBuffer_Channel,
                time_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_TimeFromFreqDomain(self, freq_channel, time_channel)
            }
            #[inline]
            pub unsafe fn ApplyReverseFftScaling(
                &mut self,
                time_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_ApplyReverseFftScaling(self, time_channel)
            }
            #[inline]
            pub unsafe fn GetCanonicalFormatFreqBuffer(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_GetCanonicalFormatFreqBuffer(self, input, output)
            }
            #[inline]
            pub unsafe fn GetPffftFormatFreqBuffer(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_GetPffftFormatFreqBuffer(self, input, output)
            }
            #[inline]
            pub unsafe fn MagnitudeFromCanonicalFreqBuffer(
                &mut self,
                freq_channel: *const root::vraudio::AudioBuffer_Channel,
                magnitude_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_MagnitudeFromCanonicalFreqBuffer(self, freq_channel, magnitude_channel)
            }
            #[inline]
            pub unsafe fn CanonicalFreqBufferFromMagnitudeAndPhase(
                &mut self,
                magnitude_channel: *const root::vraudio::AudioBuffer_Channel,
                phase_channel: *const root::vraudio::AudioBuffer_Channel,
                canonical_freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_CanonicalFreqBufferFromMagnitudeAndPhase(
                    self,
                    magnitude_channel,
                    phase_channel,
                    canonical_freq_channel,
                )
            }
            #[inline]
            pub unsafe fn CanonicalFreqBufferFromMagnitudeAndSinCosPhase(
                &mut self,
                phase_offset: usize,
                magnitude_channel: *const root::vraudio::AudioBuffer_Channel,
                sin_phase_channel: *const root::vraudio::AudioBuffer_Channel,
                cos_phase_channel: *const root::vraudio::AudioBuffer_Channel,
                canonical_freq_channel: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_CanonicalFreqBufferFromMagnitudeAndSinCosPhase(
                    self,
                    phase_offset,
                    magnitude_channel,
                    sin_phase_channel,
                    cos_phase_channel,
                    canonical_freq_channel,
                )
            }
            #[inline]
            pub unsafe fn FreqDomainConvolution(
                &mut self,
                input_a: *const root::vraudio::AudioBuffer_Channel,
                input_b: *const root::vraudio::AudioBuffer_Channel,
                scaled_output: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                FftManager_FreqDomainConvolution(self, input_a, input_b, scaled_output)
            }
            #[inline]
            pub unsafe fn new(frames_per_buffer: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                FftManager_FftManager(&mut __bindgen_tmp, frames_per_buffer);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                FftManager_FftManager_destructor(self)
            }
        }
        /// Class that provides rational resampling of audio data.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct Resampler {
            /// Rate of the interpolator section of the rational sampling rate converter.
            pub up_rate_: usize,
            /// Rate of the decimator section of the rational sampling rate convereter.
            pub down_rate_: usize,
            /// Time variable for the polyphase filter.
            pub time_modulo_up_rate_: usize,
            /// Marks the last processed sample of the input.
            pub last_processed_sample_: usize,
            /// Number of channels in the |AudioBuffer|s processed.
            pub num_channels_: usize,
            /// Number of filter coefficients in each phase of the polyphase filter.
            pub coeffs_per_phase_: usize,
            /// Filter coefficients stored in polyphase form.
            pub transposed_filter_coeffs_: root::vraudio::AudioBuffer,
            /// Filter coefficients in planar form, used for calculating the transposed
            /// /// filter.
            pub temporary_filter_coeffs_: root::vraudio::AudioBuffer,
            /// Buffer holding the samples of input required between input buffers.
            pub state_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_Resampler() {
            assert_eq!(
                ::std::mem::size_of::<Resampler>(),
                264usize,
                concat!("Size of: ", stringify!(Resampler))
            );
            assert_eq!(
                ::std::mem::align_of::<Resampler>(),
                8usize,
                concat!("Alignment of ", stringify!(Resampler))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resampler>())).up_rate_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(up_rate_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resampler>())).down_rate_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(down_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Resampler>())).time_modulo_up_rate_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(time_modulo_up_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Resampler>())).last_processed_sample_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(last_processed_sample_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resampler>())).num_channels_ as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(num_channels_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Resampler>())).coeffs_per_phase_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(coeffs_per_phase_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Resampler>())).transposed_filter_coeffs_ as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(transposed_filter_coeffs_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Resampler>())).temporary_filter_coeffs_ as *const _
                        as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(temporary_filter_coeffs_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resampler>())).state_ as *const _ as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resampler),
                    "::",
                    stringify!(state_)
                )
            );
        }
        extern "C" {
            /// Resamples an |AudioBuffer| of input data sampled at |source_frequency| to
            /// /// |destination_frequency|.
            /// ///
            /// /// @param input Input data to be resampled.
            /// /// @param output Resampled output data.
            #[link_name = "\u{1}?Process@Resampler@vraudio@@QEAAXAEBVAudioBuffer@2@PEAV32@@Z"]
            pub fn Resampler_Process(
                this: *mut root::vraudio::Resampler,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            /// Returns the maximum length which the output buffer will be, given the
            /// /// current source and destination frequencies and input length. The actual
            /// /// output length will either be this or one less.
            /// ///
            /// /// @param input_length Length of the input.
            /// /// @return Maximum length of the output.
            #[link_name = "\u{1}?GetMaxOutputLength@Resampler@vraudio@@QEBA_K_K@Z"]
            pub fn Resampler_GetMaxOutputLength(
                this: *const root::vraudio::Resampler,
                input_length: usize,
            ) -> usize;
        }
        extern "C" {
            /// Returns the next length which the output buffer will be, given the
            /// /// current source and destination frequencies and input length.
            /// ///
            /// /// @param input_length Length of the input.
            /// /// @return Next length of the output.
            #[link_name = "\u{1}?GetNextOutputLength@Resampler@vraudio@@QEBA_K_K@Z"]
            pub fn Resampler_GetNextOutputLength(
                this: *const root::vraudio::Resampler,
                input_length: usize,
            ) -> usize;
        }
        extern "C" {
            /// Sets the source and destination sampling rate as well as the number of
            /// /// channels. Note this method only resets the filter state number of channel
            /// /// changes.
            /// ///
            /// /// @param source_frequency Sampling rate of input data.
            /// /// @param destination_frequency Desired output sampling rate.
            /// /// @param num_channels Number of channels to process.
            #[link_name = "\u{1}?SetRateAndNumChannels@Resampler@vraudio@@QEAAXHH_K@Z"]
            pub fn Resampler_SetRateAndNumChannels(
                this: *mut root::vraudio::Resampler,
                source_frequency: ::std::os::raw::c_int,
                destination_frequency: ::std::os::raw::c_int,
                num_channels: usize,
            );
        }
        extern "C" {
            /// Returns whether the sampling rates provided are supported by the resampler.
            /// ///
            /// /// @param source Source sampling rate.
            /// /// @param destination Destination sampling rate.
            /// /// @return True if the sampling rate pair are supported.
            #[link_name = "\u{1}?AreSampleRatesSupported@Resampler@vraudio@@SA_NHH@Z"]
            pub fn Resampler_AreSampleRatesSupported(
                source: ::std::os::raw::c_int,
                destination: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            /// Resets the inner state of the |Resampler| allowing its use repeatedly on
            /// /// different data streams.
            #[link_name = "\u{1}?ResetState@Resampler@vraudio@@QEAAXXZ"]
            pub fn Resampler_ResetState(this: *mut root::vraudio::Resampler);
        }
        extern "C" {
            #[link_name = "\u{1}??0Resampler@vraudio@@QEAA@XZ"]
            pub fn Resampler_Resampler(this: *mut root::vraudio::Resampler);
        }
        impl Resampler {
            #[inline]
            pub unsafe fn Process(
                &mut self,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) {
                Resampler_Process(self, input, output)
            }
            #[inline]
            pub unsafe fn GetMaxOutputLength(&self, input_length: usize) -> usize {
                Resampler_GetMaxOutputLength(self, input_length)
            }
            #[inline]
            pub unsafe fn GetNextOutputLength(&self, input_length: usize) -> usize {
                Resampler_GetNextOutputLength(self, input_length)
            }
            #[inline]
            pub unsafe fn SetRateAndNumChannels(
                &mut self,
                source_frequency: ::std::os::raw::c_int,
                destination_frequency: ::std::os::raw::c_int,
                num_channels: usize,
            ) {
                Resampler_SetRateAndNumChannels(
                    self,
                    source_frequency,
                    destination_frequency,
                    num_channels,
                )
            }
            #[inline]
            pub unsafe fn AreSampleRatesSupported(
                source: ::std::os::raw::c_int,
                destination: ::std::os::raw::c_int,
            ) -> bool {
                Resampler_AreSampleRatesSupported(source, destination)
            }
            #[inline]
            pub unsafe fn ResetState(&mut self) {
                Resampler_ResetState(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Resampler_Resampler(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        /// Class performing a FFT-based overlap and add FIR convolution.
        /// Given an FFT size N and a filter size M > N/2; the filter is broken in to
        /// floor(M/(N/2)) partitions in the time domain. This results in a set of
        /// frequency domain "filters" of length (N/2)+1.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct PartitionedFftFilter {
            /// Manager for all FFT related functionality (not owned).
            pub fft_manager_: *mut root::vraudio::FftManager,
            /// Number of points in the |fft_manager_|s FFT.
            pub fft_size_: usize,
            /// Size of each partition of the filter in time domain.
            pub chunk_size_: usize,
            /// Number of frames in each buffer of input data.
            pub frames_per_buffer_: usize,
            /// Maximum filter size in samples.
            pub max_filter_size_: usize,
            /// Maximum partition count.
            pub max_num_partitions_: usize,
            /// Filter size in samples.
            pub filter_size_: usize,
            /// Partition Count.
            pub num_partitions_: usize,
            /// Kernel buffer in frequency domain.
            pub kernel_freq_domain_buffer_: root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            /// Buffer selector to switch between two filtered signal buffers.
            pub buffer_selector_: usize,
            /// The freq_domain_buffer we will write new incoming audio into.
            pub curr_front_buffer_: usize,
            /// Frequency domain buffer used to perform filtering.
            pub freq_domain_buffer_: root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            /// Two buffers that are consecutively filled with filtered signal output.
            pub filtered_time_domain_buffers_: root::vraudio::AudioBuffer,
            /// Accumulator for the outputs from each convolution partition
            pub freq_domain_accumulator_: root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            /// Temporary time domain buffer to store output when zero padding has been
            /// /// applied due to non power of two input buffer lengths.
            pub temp_zeropad_buffer_: root::vraudio::AudioBuffer,
            /// Temporary time domain buffer to hold time domain kernel chunks during
            /// /// conversion of a kernel from time to frequency domain.
            pub temp_kernel_chunk_buffer_: root::vraudio::AudioBuffer,
        }
        /// Typedef declares the data type for storing frequency domain buffers. Each
        /// /// channel stores the kernel for a partition.
        pub type PartitionedFftFilter_FreqDomainBuffer = root::vraudio::AudioBuffer;
        #[test]
        fn bindgen_test_layout_PartitionedFftFilter() {
            assert_eq!(
                ::std::mem::size_of::<PartitionedFftFilter>(),
                512usize,
                concat!("Size of: ", stringify!(PartitionedFftFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<PartitionedFftFilter>(),
                8usize,
                concat!("Alignment of ", stringify!(PartitionedFftFilter))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).fft_manager_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(fft_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).fft_size_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(fft_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).chunk_size_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(chunk_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).frames_per_buffer_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).max_filter_size_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(max_filter_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).max_num_partitions_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(max_num_partitions_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).filter_size_ as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(filter_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).num_partitions_ as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(num_partitions_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).kernel_freq_domain_buffer_
                        as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(kernel_freq_domain_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).buffer_selector_ as *const _
                        as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(buffer_selector_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).curr_front_buffer_ as *const _
                        as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(curr_front_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).freq_domain_buffer_ as *const _
                        as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(freq_domain_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).filtered_time_domain_buffers_
                        as *const _ as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(filtered_time_domain_buffers_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).freq_domain_accumulator_
                        as *const _ as usize
                },
                296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(freq_domain_accumulator_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).temp_zeropad_buffer_
                        as *const _ as usize
                },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(temp_zeropad_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PartitionedFftFilter>())).temp_kernel_chunk_buffer_
                        as *const _ as usize
                },
                440usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PartitionedFftFilter),
                    "::",
                    stringify!(temp_kernel_chunk_buffer_)
                )
            );
        }
        extern "C" {
            /// Initializes the FIR filter from a time domain kernel.
            /// ///
            /// /// @parem kernel Time domain filter to be used for processing.
            #[link_name = "\u{1}?SetTimeDomainKernel@PartitionedFftFilter@vraudio@@QEAAXAEBVChannelView@2@@Z"]
            pub fn PartitionedFftFilter_SetTimeDomainKernel(
                this: *mut root::vraudio::PartitionedFftFilter,
                kernel: *const root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Initializes the FIR filter from a precomputed frequency domain kernel.
            /// ///
            /// /// @param kernel Frequency domain filter to be used for processing.
            #[link_name = "\u{1}?SetFreqDomainKernel@PartitionedFftFilter@vraudio@@QEAAXAEBVAudioBuffer@2@@Z"]
            pub fn PartitionedFftFilter_SetFreqDomainKernel(
                this: *mut root::vraudio::PartitionedFftFilter,
                kernel: *const root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            );
        }
        extern "C" {
            /// Replaces a partition indicated by the |partition_index| with
            /// /// |kernel_chunk|'s frequency domain equivalent.
            /// ///
            /// /// @param partition_index Location (partition) of the time domain filter we
            /// ///     wish to replace.
            /// /// @param kernel_chunk |fft_size_|/2 length chunk of a filter used to
            /// ///     replace the |partition_index|th partition.
            #[link_name = "\u{1}?ReplacePartition@PartitionedFftFilter@vraudio@@QEAAX_KAEBVChannelView@2@@Z"]
            pub fn PartitionedFftFilter_ReplacePartition(
                this: *mut root::vraudio::PartitionedFftFilter,
                partition_index: usize,
                kernel_chunk: *const root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Alters the filter length by adding or removing partitions in the frequency
            /// /// domain. If |new_filter_size| is not a multiple of |chunk_size_| (i.e.
            /// /// frames per buffer), then the time domain filter kernel will be zeropadded
            /// /// to a multiple of |chunk_size_|.
            /// ///
            /// /// @param new_filter_size New length of the time domain filter kernel.
            #[link_name = "\u{1}?SetFilterLength@PartitionedFftFilter@vraudio@@QEAAX_K@Z"]
            pub fn PartitionedFftFilter_SetFilterLength(
                this: *mut root::vraudio::PartitionedFftFilter,
                new_filter_size: usize,
            );
        }
        extern "C" {
            /// Processes a block of frequency domain samples. The size of the input
            /// /// block must be |fft_size_|.
            /// ///
            /// /// @param Frequency domain input buffer.
            #[link_name = "\u{1}?Filter@PartitionedFftFilter@vraudio@@QEAAXAEBVChannelView@2@@Z"]
            pub fn PartitionedFftFilter_Filter(
                this: *mut root::vraudio::PartitionedFftFilter,
                input: *const root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Returns block of filtered signal output of size |fft_size_|/2.
            /// ///
            /// /// @param output Time domain block filtered with the given kernel.
            #[link_name = "\u{1}?GetFilteredSignal@PartitionedFftFilter@vraudio@@QEAAXPEAVChannelView@2@@Z"]
            pub fn PartitionedFftFilter_GetFilteredSignal(
                this: *mut root::vraudio::PartitionedFftFilter,
                output: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Resets the filter state.
            #[link_name = "\u{1}?Clear@PartitionedFftFilter@vraudio@@QEAAXXZ"]
            pub fn PartitionedFftFilter_Clear(this: *mut root::vraudio::PartitionedFftFilter);
        }
        extern "C" {
            /// Constructor preallocates memory based on the |filter_size|. This can be
            /// /// used for simplicity if the filter size will be constant after creation.
            /// ///
            /// /// @param filter_size Length of the time domain filter in samples. This will
            /// ///     be increased such that it becomes a multiple of |chunk_size_|.
            /// /// @param frames_per_buffer Number of points in each time domain input buffer.
            /// /// @param fft_manager Pointer to a manager to perform FFT transformations.
            #[link_name = "\u{1}??0PartitionedFftFilter@vraudio@@QEAA@_K0PEAVFftManager@1@@Z"]
            pub fn PartitionedFftFilter_PartitionedFftFilter(
                this: *mut root::vraudio::PartitionedFftFilter,
                filter_size: usize,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            );
        }
        extern "C" {
            /// Constructor preallocates memory based on the |max_filter_size|. The
            /// /// |fft_size_| will be twice |frames_per_buffer| if this is a power of two and
            /// /// twice the next larger power of two if it is not.
            /// ///
            /// /// @param filter_size Length of the time domain filter in samples. This will
            /// ///     be increased such that it becomes a multiple of |chunk_size_|.
            /// /// @param frames_per_buffer Number of points in each time domain input buffer.
            /// /// @param max_filter_size Maximum length that |filter_size| can get.
            /// /// @param fft_manager Pointer to a manager for all fft related functionality.
            #[link_name = "\u{1}??0PartitionedFftFilter@vraudio@@QEAA@_K00PEAVFftManager@1@@Z"]
            pub fn PartitionedFftFilter_PartitionedFftFilter1(
                this: *mut root::vraudio::PartitionedFftFilter,
                filter_size: usize,
                frames_per_buffer: usize,
                max_filter_size: usize,
                fft_manager: *mut root::vraudio::FftManager,
            );
        }
        impl PartitionedFftFilter {
            #[inline]
            pub unsafe fn SetTimeDomainKernel(
                &mut self,
                kernel: *const root::vraudio::AudioBuffer_Channel,
            ) {
                PartitionedFftFilter_SetTimeDomainKernel(self, kernel)
            }
            #[inline]
            pub unsafe fn SetFreqDomainKernel(
                &mut self,
                kernel: *const root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            ) {
                PartitionedFftFilter_SetFreqDomainKernel(self, kernel)
            }
            #[inline]
            pub unsafe fn ReplacePartition(
                &mut self,
                partition_index: usize,
                kernel_chunk: *const root::vraudio::AudioBuffer_Channel,
            ) {
                PartitionedFftFilter_ReplacePartition(self, partition_index, kernel_chunk)
            }
            #[inline]
            pub unsafe fn SetFilterLength(&mut self, new_filter_size: usize) {
                PartitionedFftFilter_SetFilterLength(self, new_filter_size)
            }
            #[inline]
            pub unsafe fn Filter(&mut self, input: *const root::vraudio::AudioBuffer_Channel) {
                PartitionedFftFilter_Filter(self, input)
            }
            #[inline]
            pub unsafe fn GetFilteredSignal(
                &mut self,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                PartitionedFftFilter_GetFilteredSignal(self, output)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                PartitionedFftFilter_Clear(self)
            }
            #[inline]
            pub unsafe fn new(
                filter_size: usize,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PartitionedFftFilter_PartitionedFftFilter(
                    &mut __bindgen_tmp,
                    filter_size,
                    frames_per_buffer,
                    fft_manager,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                filter_size: usize,
                frames_per_buffer: usize,
                max_filter_size: usize,
                fft_manager: *mut root::vraudio::FftManager,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PartitionedFftFilter_PartitionedFftFilter1(
                    &mut __bindgen_tmp,
                    filter_size,
                    frames_per_buffer,
                    max_filter_size,
                    fft_manager,
                );
                __bindgen_tmp
            }
        }
        /// Decodes an Ambisonic sound field, of an arbitrary order, to binaural stereo,
        /// by performing convolution in the spherical harmonics domain. The order (hence
        /// the number of channels) of the input must match the order (hence the number
        /// of channels) of the spherical harmonic-encoded Head Related Impulse Responses
        /// (HRIRs). Assumes that HRIRs are symmetric with respect to the sagittal plane.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct AmbisonicBinauralDecoder {
            /// Manager for all FFT related functionality (not owned).
            pub fft_manager_: *mut root::vraudio::FftManager,
            /// Spherical Harmonic HRIR filter kernels.
            pub sh_hrir_filters_: [u64; 3usize],
            /// Frequency domain representation of the input signal.
            pub freq_input_: root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
            /// Temporary audio buffer to store the convolution output for asymmetric or
            /// /// symmetric spherical harmonic HRIR.
            pub filtered_input_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_AmbisonicBinauralDecoder() {
            assert_eq!(
                ::std::mem::size_of::<AmbisonicBinauralDecoder>(),
                176usize,
                concat!("Size of: ", stringify!(AmbisonicBinauralDecoder))
            );
            assert_eq!(
                ::std::mem::align_of::<AmbisonicBinauralDecoder>(),
                8usize,
                concat!("Alignment of ", stringify!(AmbisonicBinauralDecoder))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoder>())).fft_manager_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoder),
                    "::",
                    stringify!(fft_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoder>())).sh_hrir_filters_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoder),
                    "::",
                    stringify!(sh_hrir_filters_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoder>())).freq_input_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoder),
                    "::",
                    stringify!(freq_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoder>())).filtered_input_ as *const _
                        as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoder),
                    "::",
                    stringify!(filtered_input_)
                )
            );
        }
        extern "C" {
            /// Processes an Ambisonic sound field input and outputs a binaurally decoded
            /// /// stereo buffer.
            /// ///
            /// /// @param input Input buffer to be processed.
            /// /// @param output Pointer to a stereo output buffer.
            #[link_name = "\u{1}?Process@AmbisonicBinauralDecoder@vraudio@@QEAAXAEBVAudioBuffer@2@PEAV32@@Z"]
            pub fn AmbisonicBinauralDecoder_Process(
                this: *mut root::vraudio::AmbisonicBinauralDecoder,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            /// Constructs an |AmbisonicBinauralDecoder| from an |AudioBuffer| containing
            /// /// spherical harmonic representation of HRIRs. The order of spherical
            /// /// harmonic-encoded HRIRs (hence the number of channels) must match the order
            /// /// of the Ambisonic sound field input.
            /// ///
            /// /// @param sh_hrirs |AudioBuffer| containing time-domain spherical harmonic
            /// ///   encoded symmetric HRIRs.
            /// /// @param frames_per_buffer Number of frames in each input/output buffer.
            /// /// @param fft_manager Pointer to a manager to perform FFT transformations.
            #[link_name = "\u{1}??0AmbisonicBinauralDecoder@vraudio@@QEAA@AEBVAudioBuffer@1@_KPEAVFftManager@1@@Z"]
            pub fn AmbisonicBinauralDecoder_AmbisonicBinauralDecoder(
                this: *mut root::vraudio::AmbisonicBinauralDecoder,
                sh_hrirs: *const root::vraudio::AudioBuffer,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            );
        }
        impl AmbisonicBinauralDecoder {
            #[inline]
            pub unsafe fn Process(
                &mut self,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) {
                AmbisonicBinauralDecoder_Process(self, input, output)
            }
            #[inline]
            pub unsafe fn new(
                sh_hrirs: *const root::vraudio::AudioBuffer,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AmbisonicBinauralDecoder_AmbisonicBinauralDecoder(
                    &mut __bindgen_tmp,
                    sh_hrirs,
                    frames_per_buffer,
                    fft_manager,
                );
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq)]
        pub struct ObjectTransform {
            pub position: root::vraudio::WorldPosition,
            pub rotation: root::vraudio::WorldRotation,
        }
        #[test]
        fn bindgen_test_layout_ObjectTransform() {
            assert_eq!(
                ::std::mem::size_of::<ObjectTransform>(),
                28usize,
                concat!("Size of: ", stringify!(ObjectTransform))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectTransform>(),
                4usize,
                concat!("Alignment of ", stringify!(ObjectTransform))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectTransform>())).position as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectTransform),
                    "::",
                    stringify!(position)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectTransform>())).rotation as *const _ as usize
                },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectTransform),
                    "::",
                    stringify!(rotation)
                )
            );
        }
        pub const AttenuationType_kInput: root::vraudio::AttenuationType = 0;
        pub const AttenuationType_kDirect: root::vraudio::AttenuationType = 1;
        pub const AttenuationType_kReflections: root::vraudio::AttenuationType = 2;
        pub const AttenuationType_kReverb: root::vraudio::AttenuationType = 3;
        pub const AttenuationType_kNumAttenuationTypes: root::vraudio::AttenuationType = 4;
        /// Gain attenuation types for audio sources.
        pub type AttenuationType = i32;
        /// Parameters describing an audio source.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SourceParameters {
            /// Object transform associated with this buffer.
            pub object_transform: root::vraudio::ObjectTransform,
            /// Angular spread in degrees. Range [0, 360].
            pub spread_deg: f32,
            /// Source gain factor.
            pub gain: f32,
            /// Source gain attenuation factors to be calculated per each buffer.
            pub attenuations: [f32; 4usize],
            /// Distance attenuation. Value 1 represents no attenuation should be applied,
            /// /// value 0 will fully attenuate the volume. Range [0, 1].
            pub distance_attenuation: f32,
            /// Distance attenuation rolloff model to use.
            pub distance_rolloff_model: root::vraudio::DistanceRolloffModel,
            /// Minimum distance at which to apply distance attenuation.
            pub minimum_distance: f32,
            /// Maximum distance at which to apply distance attenuation.
            pub maximum_distance: f32,
            /// Alpha weighting of source's directivity pattern. This sets the balance
            /// /// between the dipole and omnidirectional directivity patterns which combine
            /// /// to produce the single directivity output value. Range [0, 1], where 0 is
            /// /// fully omnidirectional and 1 is fully dipole.
            pub directivity_alpha: f32,
            /// Source directivity order. Increasing this value increases the directivity
            /// /// towards the front of the source. Range [1, inf).
            pub directivity_order: f32,
            /// Alpha weighting of listener's directivity pattern. This sets the balance
            /// /// between the dipole and omnidirectional pickup patterns which combine to
            /// /// produce the single output value. Range [0, 1], where 0 is fully
            /// /// omnidirectional and 1 is fully dipole.
            pub listener_directivity_alpha: f32,
            /// Listener directivity order. Increasing this value increases the directivity
            /// /// towards the front of the listener. Range [1, inf).
            pub listener_directivity_order: f32,
            /// Occlusion intensity. Value 0 represents no occlusion, values greater than 1
            /// /// represent multiple occlusions. The intensity of each occlusion is scaled
            /// /// in range [0, 1].
            pub occlusion_intensity: f32,
            /// Near field effect gain. Range [0, 9].
            pub near_field_gain: f32,
            /// Source gain factor for the room effects.
            pub room_effects_gain: f32,
            /// Whether the source uses binaural rendering or stereo panning.
            pub enable_hrtf: bool,
        }
        #[test]
        fn bindgen_test_layout_SourceParameters() {
            assert_eq!(
                ::std::mem::size_of::<SourceParameters>(),
                100usize,
                concat!("Size of: ", stringify!(SourceParameters))
            );
            assert_eq!(
                ::std::mem::align_of::<SourceParameters>(),
                4usize,
                concat!("Alignment of ", stringify!(SourceParameters))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).object_transform as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(object_transform)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).spread_deg as *const _ as usize
                },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(spread_deg)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SourceParameters>())).gain as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(gain)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).attenuations as *const _ as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(attenuations)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).distance_attenuation as *const _
                        as usize
                },
                52usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(distance_attenuation)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).distance_rolloff_model as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(distance_rolloff_model)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).minimum_distance as *const _
                        as usize
                },
                60usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(minimum_distance)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).maximum_distance as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(maximum_distance)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).directivity_alpha as *const _
                        as usize
                },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(directivity_alpha)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).directivity_order as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(directivity_order)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).listener_directivity_alpha
                        as *const _ as usize
                },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(listener_directivity_alpha)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).listener_directivity_order
                        as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(listener_directivity_order)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).occlusion_intensity as *const _
                        as usize
                },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(occlusion_intensity)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).near_field_gain as *const _
                        as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(near_field_gain)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).room_effects_gain as *const _
                        as usize
                },
                92usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(room_effects_gain)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParameters>())).enable_hrtf as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParameters),
                    "::",
                    stringify!(enable_hrtf)
                )
            );
        }
        /// Class that manages the corresponding parameters of each registered source.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq)]
        pub struct SourceParametersManager {
            /// Registered source parameters.
            pub parameters_: [u64; 8usize],
        }
        /// Alias for the parameters process closure type.
        pub type SourceParametersManager_Process = u8;
        #[test]
        fn bindgen_test_layout_SourceParametersManager() {
            assert_eq!(
                ::std::mem::size_of::<SourceParametersManager>(),
                64usize,
                concat!("Size of: ", stringify!(SourceParametersManager))
            );
            assert_eq!(
                ::std::mem::align_of::<SourceParametersManager>(),
                8usize,
                concat!("Alignment of ", stringify!(SourceParametersManager))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SourceParametersManager>())).parameters_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SourceParametersManager),
                    "::",
                    stringify!(parameters_)
                )
            );
        }
        extern "C" {
            /// Registers new source parameters for given |source_id|.
            /// ///
            /// /// @param source_id Source id.
            #[link_name = "\u{1}?Register@SourceParametersManager@vraudio@@QEAAXH@Z"]
            pub fn SourceParametersManager_Register(
                this: *mut root::vraudio::SourceParametersManager,
                source_id: root::vraudio::SourceId,
            );
        }
        extern "C" {
            /// Unregisters the source parameters for given |source_id|.
            /// ///
            /// /// @param source_id Source id.
            #[link_name = "\u{1}?Unregister@SourceParametersManager@vraudio@@QEAAXH@Z"]
            pub fn SourceParametersManager_Unregister(
                this: *mut root::vraudio::SourceParametersManager,
                source_id: root::vraudio::SourceId,
            );
        }
        extern "C" {
            /// Returns read-only source parameters for given |source_id|.
            /// ///
            /// /// @param source_id Source id.
            /// /// @return Read-only source parameters, nullptr if |source_id| not found.
            #[link_name = "\u{1}?GetParameters@SourceParametersManager@vraudio@@QEBAPEBUSourceParameters@2@H@Z"]
            pub fn SourceParametersManager_GetParameters(
                this: *const root::vraudio::SourceParametersManager,
                source_id: root::vraudio::SourceId,
            ) -> *const root::vraudio::SourceParameters;
        }
        extern "C" {
            /// Returns mutable source parameters for given |source_id|.
            /// ///
            /// /// @param source_id Source id.
            /// /// @return Mutable source parameters, nullptr if |source_id| not found.
            #[link_name = "\u{1}?GetMutableParameters@SourceParametersManager@vraudio@@QEAAPEAUSourceParameters@2@H@Z"]
            pub fn SourceParametersManager_GetMutableParameters(
                this: *mut root::vraudio::SourceParametersManager,
                source_id: root::vraudio::SourceId,
            ) -> *mut root::vraudio::SourceParameters;
        }
        extern "C" {
            /// Executes given |process| for the parameters of each registered source.
            /// ///
            /// /// @param process Parameters processing method.
            #[link_name = "\u{1}?ProcessAllParameters@SourceParametersManager@vraudio@@QEAAXAEBV?$function@$$A6AXPEAUSourceParameters@vraudio@@@Z@std@@@Z"]
            pub fn SourceParametersManager_ProcessAllParameters(
                this: *mut root::vraudio::SourceParametersManager,
                process: *const root::vraudio::SourceParametersManager_Process,
            );
        }
        impl SourceParametersManager {
            #[inline]
            pub unsafe fn Register(&mut self, source_id: root::vraudio::SourceId) {
                SourceParametersManager_Register(self, source_id)
            }
            #[inline]
            pub unsafe fn Unregister(&mut self, source_id: root::vraudio::SourceId) {
                SourceParametersManager_Unregister(self, source_id)
            }
            #[inline]
            pub unsafe fn GetParameters(
                &self,
                source_id: root::vraudio::SourceId,
            ) -> *const root::vraudio::SourceParameters {
                SourceParametersManager_GetParameters(self, source_id)
            }
            #[inline]
            pub unsafe fn GetMutableParameters(
                &mut self,
                source_id: root::vraudio::SourceId,
            ) -> *mut root::vraudio::SourceParameters {
                SourceParametersManager_GetMutableParameters(self, source_id)
            }
            #[inline]
            pub unsafe fn ProcessAllParameters(
                &mut self,
                process: *const root::vraudio::SourceParametersManager_Process,
            ) {
                SourceParametersManager_ProcessAllParameters(self, process)
            }
        }
        /// Contains system-wide settings and parameters. Note that this class is not
        /// thread-safe. Updating system parameters must be avoided during the audio
        /// graph processing.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SystemSettings {
            /// Sampling rate.
            pub sample_rate_hz_: ::std::os::raw::c_int,
            /// Frames per buffer.
            pub frames_per_buffer_: usize,
            /// Number of channels per buffer.
            pub num_channels_: usize,
            /// The most recently updated head rotation and position.
            pub head_rotation_: root::vraudio::WorldRotation,
            pub head_position_: root::vraudio::WorldPosition,
            /// Source parameters manager.
            pub source_parameters_manager_: root::vraudio::SourceParametersManager,
            /// Master gain in amplitude.
            pub master_gain_: f32,
            /// Current reflection properties of the environment.
            pub reflection_properties_: root::vraudio::ReflectionProperties,
            /// Current reverb properties of the environment.
            pub reverb_properties_: root::vraudio::ReverbProperties,
            /// Defines the state of the global speaker mode.
            pub stereo_speaker_mode_: bool,
        }
        #[test]
        fn bindgen_test_layout_SystemSettings() {
            assert_eq!(
                ::std::mem::size_of::<SystemSettings>(),
                240usize,
                concat!("Size of: ", stringify!(SystemSettings))
            );
            assert_eq!(
                ::std::mem::align_of::<SystemSettings>(),
                8usize,
                concat!("Alignment of ", stringify!(SystemSettings))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).sample_rate_hz_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(sample_rate_hz_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).frames_per_buffer_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).num_channels_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(num_channels_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).head_rotation_ as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(head_rotation_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).head_position_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(head_position_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).source_parameters_manager_
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(source_parameters_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).master_gain_ as *const _ as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(master_gain_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).reflection_properties_ as *const _
                        as usize
                },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(reflection_properties_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).reverb_properties_ as *const _
                        as usize
                },
                196usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(reverb_properties_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SystemSettings>())).stereo_speaker_mode_ as *const _
                        as usize
                },
                236usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SystemSettings),
                    "::",
                    stringify!(stereo_speaker_mode_)
                )
            );
        }
        #[repr(C)]
        pub struct Node__bindgen_vtable(::std::os::raw::c_void);
        /// Graphs are managed through shared_ptrs. Orphaned nodes are kept
        /// alive as long as they output to a living input. Ownership is
        /// unidirectional -- from input to output -- in order to avoid
        /// circular dependencies.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Node {
            pub vtable_: *const Node__bindgen_vtable,
            pub _base: [u64; 2usize],
        }
        /// An endpoint for a node, this object consumes data from any connected
        /// /// outputs. Because an input may be connected to more than one output, it
        /// /// returns a vector of read data. All outputs must be of the same type.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Node_Input {
            pub outputs_: root::vraudio::Node_Input_OutputNodeMap,
            pub read_data_: u8,
        }
        /// Unordered map that stores pairs of input Node instances and their
        /// /// |Output| member.
        pub type Node_Input_OutputNodeMap = u8;
        /// An endpoint for a node, this object produces data for any connected inputs.
        /// /// Because an output may have more than one input, this object will duplicate
        /// /// any computed data, once for each connected input. All inputs must be of the
        /// /// same type.
        /// ///
        /// /// If an output does not have any data to deliver, it will ask its parent node
        /// /// to process more data. It is assumed that after processing, some new data
        /// /// will be written to this output.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Node_Output {
            pub inputs_: u8,
            pub written_data_: u8,
            pub parent_: *mut root::vraudio::Node,
        }
        /// Signature of copy operator.
        pub type Node_Output_CopyOperator<T> =
            ::std::option::Option<unsafe extern "C" fn(arg1: *const T) -> T>;
        #[test]
        fn bindgen_test_layout_Node() {
            assert_eq!(
                ::std::mem::size_of::<Node>(),
                24usize,
                concat!("Size of: ", stringify!(Node))
            );
            assert_eq!(
                ::std::mem::align_of::<Node>(),
                8usize,
                concat!("Alignment of ", stringify!(Node))
            );
        }
        #[repr(C)]
        pub struct PublisherNode__bindgen_vtable(::std::os::raw::c_void);
        /// @tparam OutputType Type of the output container being streamed.
        /// @interface
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct PublisherNode {
            pub vtable_: *const PublisherNode__bindgen_vtable,
        }
        #[repr(C)]
        pub struct SubscriberNode__bindgen_vtable(::std::os::raw::c_void);
        /// @tparam InputType Input data type, i. e., the output data type of nodes to
        /// connect to.
        /// @interface
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct SubscriberNode {
            pub vtable_: *const SubscriberNode__bindgen_vtable,
        }
        /// Audio processing node that reads from multiple inputs, processes the
        /// received data and outputs its result.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ProcessingNode {
            pub _base: root::vraudio::Node,
            pub _base_1: root::vraudio::SubscriberNode,
            pub _base_2: root::vraudio::PublisherNode,
            /// Input stream to poll for incoming data.
            pub input_stream_: root::vraudio::Node_Input,
            /// Output stream to write processed data to.
            pub output_stream_: root::vraudio::Node_Output,
            /// Flag that indicates if |AudioProcess| should be called in case no input
            /// /// data is available.
            pub process_on_no_input_: bool,
        }
        pub type ProcessingNode_SubscriberNodeType = root::vraudio::SubscriberNode;
        pub type ProcessingNode_PublisherNodeType = root::vraudio::PublisherNode;
        /// Helper class to manage incoming |AudioBuffer|s.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ProcessingNode_NodeInput {
            /// Const reference to vector of input |AudioBuffer|s.
            pub input_vector_: *const [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_ProcessingNode_NodeInput() {
            assert_eq!(
                ::std::mem::size_of::<ProcessingNode_NodeInput>(),
                8usize,
                concat!("Size of: ", stringify!(ProcessingNode_NodeInput))
            );
            assert_eq!(
                ::std::mem::align_of::<ProcessingNode_NodeInput>(),
                8usize,
                concat!("Alignment of ", stringify!(ProcessingNode_NodeInput))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProcessingNode_NodeInput>())).input_vector_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProcessingNode_NodeInput),
                    "::",
                    stringify!(input_vector_)
                )
            );
        }
        extern "C" {
            /// Returns a nullptr if zero or more than one input buffers are available.
            /// /// Otherwise a pointer to the single input |AudioBuffer| is returned. This
            /// /// method should be used if only a single input |AudioBuffer| is expected.
            /// ///
            /// /// @return Pointer to single input |AudioBuffer|.
            #[link_name = "\u{1}?GetSingleInput@NodeInput@ProcessingNode@vraudio@@QEBAPEBVAudioBuffer@3@XZ"]
            pub fn ProcessingNode_NodeInput_GetSingleInput(
                this: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Returns vector with input |AudioBuffer|s.
            /// ///
            /// /// @return Pointer to single input |AudioBuffer|.
            #[link_name = "\u{1}?GetInputBuffers@NodeInput@ProcessingNode@vraudio@@QEBAAEBV?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@XZ"]
            pub fn ProcessingNode_NodeInput_GetInputBuffers(
                this: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const [u64; 3usize];
        }
        extern "C" {
            /// Constructor.
            /// ///
            /// /// @param input_vector Vector containing pointers to incoming
            /// ///     |AudioBuffer|s.
            #[link_name = "\u{1}??0NodeInput@ProcessingNode@vraudio@@QEAA@AEBV?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@@Z"]
            pub fn ProcessingNode_NodeInput_NodeInput(
                this: *mut root::vraudio::ProcessingNode_NodeInput,
                input_vector: *const [u64; 3usize],
            );
        }
        impl ProcessingNode_NodeInput {
            #[inline]
            pub unsafe fn GetSingleInput(&self) -> *const root::vraudio::AudioBuffer {
                ProcessingNode_NodeInput_GetSingleInput(self)
            }
            #[inline]
            pub unsafe fn GetInputBuffers(&self) -> *const [u64; 3usize] {
                ProcessingNode_NodeInput_GetInputBuffers(self)
            }
            #[inline]
            pub unsafe fn new(input_vector: *const [u64; 3usize]) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ProcessingNode_NodeInput_NodeInput(&mut __bindgen_tmp, input_vector);
                __bindgen_tmp
            }
        }
        #[test]
        fn bindgen_test_layout_ProcessingNode() {
            assert_eq!(
                ::std::mem::size_of::<ProcessingNode>(),
                184usize,
                concat!("Size of: ", stringify!(ProcessingNode))
            );
            assert_eq!(
                ::std::mem::align_of::<ProcessingNode>(),
                8usize,
                concat!("Alignment of ", stringify!(ProcessingNode))
            );
        }
        extern "C" {
            /// By default, calls to AudioProcess() are skipped in case of empty input
            /// /// buffers. This enables this node to process audio buffers in the absence of
            /// /// input data (which is needed for instance for a reverberation effect).
            #[link_name = "\u{1}?EnableProcessOnEmptyInput@ProcessingNode@vraudio@@QEAAX_N@Z"]
            pub fn ProcessingNode_EnableProcessOnEmptyInput(
                this: *mut root::vraudio::ProcessingNode,
                enable: bool,
            );
        }
        extern "C" {
            /// Calls |CleanUp| on all connected input nodes.
            #[link_name = "\u{1}?CallCleanUpOnInputNodes@ProcessingNode@vraudio@@IEAAXXZ"]
            pub fn ProcessingNode_CallCleanUpOnInputNodes(this: *mut root::vraudio::ProcessingNode);
        }
        extern "C" {
            #[link_name = "\u{1}??0ProcessingNode@vraudio@@QEAA@XZ"]
            pub fn ProcessingNode_ProcessingNode(this: *mut root::vraudio::ProcessingNode);
        }
        impl ProcessingNode {
            #[inline]
            pub unsafe fn EnableProcessOnEmptyInput(&mut self, enable: bool) {
                ProcessingNode_EnableProcessOnEmptyInput(self, enable)
            }
            #[inline]
            pub unsafe fn CallCleanUpOnInputNodes(&mut self) {
                ProcessingNode_CallCleanUpOnInputNodes(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ProcessingNode_ProcessingNode(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// SubscriberNode<InputType> implementation.
            #[link_name = "\u{1}?Connect@ProcessingNode@vraudio@@UEAAXAEBV?$shared_ptr@V?$PublisherNode@PEBVAudioBuffer@vraudio@@@vraudio@@@std@@@Z"]
            pub fn ProcessingNode_Connect(
                this: *mut ::std::os::raw::c_void,
                publisher_node: *const u8,
            );
        }
        extern "C" {
            /// Node implementation.
            #[link_name = "\u{1}?Process@ProcessingNode@vraudio@@UEAAXXZ"]
            pub fn ProcessingNode_Process(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?CleanUp@ProcessingNode@vraudio@@UEAA_NXZ"]
            pub fn ProcessingNode_CleanUp(this: *mut ::std::os::raw::c_void) -> bool;
        }
        /// Class that takes two input buffers and produces an output buffer by applying
        /// linear crossfade between the inputs.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct BufferCrossfader {
            /// Stereo audio buffer to store crossfade decay and growth multipliers.
            pub crossfade_buffer_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_BufferCrossfader() {
            assert_eq!(
                ::std::mem::size_of::<BufferCrossfader>(),
                72usize,
                concat!("Size of: ", stringify!(BufferCrossfader))
            );
            assert_eq!(
                ::std::mem::align_of::<BufferCrossfader>(),
                8usize,
                concat!("Alignment of ", stringify!(BufferCrossfader))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<BufferCrossfader>())).crossfade_buffer_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferCrossfader),
                    "::",
                    stringify!(crossfade_buffer_)
                )
            );
        }
        extern "C" {
            /// Applies linear crossfade for given input buffers and stores the result in
            /// /// |output| buffer. Note that, in-place processing is *not* supported by this
            /// /// method, the output buffer must be different than the input buffers.
            /// ///
            /// /// @param input_fade_in Input buffer to fade-in to.
            /// /// @param input_fade_out Input buffer to fade-out from.
            /// /// @param output Output buffer to store the crossfaded result.
            #[link_name = "\u{1}?ApplyLinearCrossfade@BufferCrossfader@vraudio@@QEBAXAEBVAudioBuffer@2@0PEAV32@@Z"]
            pub fn BufferCrossfader_ApplyLinearCrossfade(
                this: *const root::vraudio::BufferCrossfader,
                input_fade_in: *const root::vraudio::AudioBuffer,
                input_fade_out: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0BufferCrossfader@vraudio@@QEAA@_K@Z"]
            pub fn BufferCrossfader_BufferCrossfader(
                this: *mut root::vraudio::BufferCrossfader,
                num_frames: usize,
            );
        }
        impl BufferCrossfader {
            #[inline]
            pub unsafe fn ApplyLinearCrossfade(
                &self,
                input_fade_in: *const root::vraudio::AudioBuffer,
                input_fade_out: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) {
                BufferCrossfader_ApplyLinearCrossfade(self, input_fade_in, input_fade_out, output)
            }
            #[inline]
            pub unsafe fn new(num_frames: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                BufferCrossfader_BufferCrossfader(&mut __bindgen_tmp, num_frames);
                __bindgen_tmp
            }
        }
        /// Node that takes an ambisonic soundfield as input and renders a binaural
        /// stereo buffer as output.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct AmbisonicBinauralDecoderNode {
            pub _base: root::vraudio::ProcessingNode,
            pub system_settings_: *const root::vraudio::SystemSettings,
            /// Number of Ambisonic channels.
            pub num_ambisonic_channels_: usize,
            /// Denotes if the stereo speaker mode is enabled.
            pub is_stereo_speaker_mode_: bool,
            /// Ambisonic decoder used to render binaural output.
            pub ambisonic_binaural_decoder_: u64,
            pub num_frames_processed_on_empty_input_: usize,
            /// Stereo output buffer.
            pub stereo_output_buffer_: root::vraudio::AudioBuffer,
            /// Silence mono buffer to render reverb tails.
            pub silence_input_buffer_: root::vraudio::AudioBuffer,
            /// Buffer crossfader to apply linear crossfade when the stereo speaker mode is
            /// /// changed.
            pub crossfader_: root::vraudio::BufferCrossfader,
            /// Stereo output buffer to store the crossfaded decode output when necessary.
            pub crossfaded_output_buffer_: root::vraudio::AudioBuffer,
            /// Temporary crossfade buffer to store the intermediate stereo output.
            pub temp_crossfade_buffer_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_AmbisonicBinauralDecoderNode() {
            assert_eq!(
                ::std::mem::size_of::<AmbisonicBinauralDecoderNode>(),
                584usize,
                concat!("Size of: ", stringify!(AmbisonicBinauralDecoderNode))
            );
            assert_eq!(
                ::std::mem::align_of::<AmbisonicBinauralDecoderNode>(),
                8usize,
                concat!("Alignment of ", stringify!(AmbisonicBinauralDecoderNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).system_settings_
                        as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).num_ambisonic_channels_
                        as *const _ as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(num_ambisonic_channels_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).is_stereo_speaker_mode_
                        as *const _ as usize
                },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(is_stereo_speaker_mode_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>()))
                        .ambisonic_binaural_decoder_ as *const _ as usize
                },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(ambisonic_binaural_decoder_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>()))
                        .num_frames_processed_on_empty_input_ as *const _
                        as usize
                },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(num_frames_processed_on_empty_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).stereo_output_buffer_
                        as *const _ as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(stereo_output_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).silence_input_buffer_
                        as *const _ as usize
                },
                296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(silence_input_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).crossfader_ as *const _
                        as usize
                },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(crossfader_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>()))
                        .crossfaded_output_buffer_ as *const _ as usize
                },
                440usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(crossfaded_output_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicBinauralDecoderNode>())).temp_crossfade_buffer_
                        as *const _ as usize
                },
                512usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicBinauralDecoderNode),
                    "::",
                    stringify!(temp_crossfade_buffer_)
                )
            );
        }
        extern "C" {
            /// Initializes AmbisonicBinauralDecoderNode class.
            /// ///
            /// /// @param system_settings Global system configuration.
            /// /// @param ambisonic_order Ambisonic order.
            /// /// @param sh_hrir_filename Filename to load the HRIR data from.
            /// /// @param fft_manager Pointer to a manager to perform FFT transformations.
            /// /// @resampler Pointer to a resampler used to convert HRIRs to the system rate.
            #[link_name = "\u{1}??0AmbisonicBinauralDecoderNode@vraudio@@QEAA@AEBVSystemSettings@1@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVFftManager@1@PEAVResampler@1@@Z"]
            pub fn AmbisonicBinauralDecoderNode_AmbisonicBinauralDecoderNode(
                this: *mut root::vraudio::AmbisonicBinauralDecoderNode,
                system_settings: *const root::vraudio::SystemSettings,
                ambisonic_order: ::std::os::raw::c_int,
                sh_hrir_filename: *const root::std::string,
                fft_manager: *mut root::vraudio::FftManager,
                resampler: *mut root::vraudio::Resampler,
            );
        }
        impl AmbisonicBinauralDecoderNode {
            #[inline]
            pub unsafe fn new(
                system_settings: *const root::vraudio::SystemSettings,
                ambisonic_order: ::std::os::raw::c_int,
                sh_hrir_filename: *const root::std::string,
                fft_manager: *mut root::vraudio::FftManager,
                resampler: *mut root::vraudio::Resampler,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AmbisonicBinauralDecoderNode_AmbisonicBinauralDecoderNode(
                    &mut __bindgen_tmp,
                    system_settings,
                    ambisonic_order,
                    sh_hrir_filename,
                    fft_manager,
                    resampler,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DAmbisonicBinauralDecoderNode@vraudio@@QEAAXXZ"]
            pub fn AmbisonicBinauralDecoderNode_AmbisonicBinauralDecoderNode_destructor(
                this: *mut root::vraudio::AmbisonicBinauralDecoderNode,
            );
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@AmbisonicBinauralDecoderNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn AmbisonicBinauralDecoderNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Processor class which applies a gain to a vector of samples from an audio
        /// buffer. A short linear ramp is applied to the gain to reduce audible
        /// artifacts in the output.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GainProcessor {
            /// Latest gain value to be applied to buffer values.
            pub current_gain_: f32,
            /// Flag to indiciate if an initial gain has been assigned.
            pub is_initialized_: bool,
        }
        #[test]
        fn bindgen_test_layout_GainProcessor() {
            assert_eq!(
                ::std::mem::size_of::<GainProcessor>(),
                8usize,
                concat!("Size of: ", stringify!(GainProcessor))
            );
            assert_eq!(
                ::std::mem::align_of::<GainProcessor>(),
                4usize,
                concat!("Alignment of ", stringify!(GainProcessor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainProcessor>())).current_gain_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainProcessor),
                    "::",
                    stringify!(current_gain_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainProcessor>())).is_initialized_ as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainProcessor),
                    "::",
                    stringify!(is_initialized_)
                )
            );
        }
        extern "C" {
            /// Applies gain supplied to the input samples.
            /// ///
            /// /// @param target_gain Target gain value.
            /// /// @param input Samples to which gain will be applied.
            /// /// @param output Samples to which gain has been applied.
            /// /// @param accumulate_output True if the processed input should be mixed into
            /// ///     the output. Otherwise, the output will be replaced by the processed
            /// ///     input.
            #[link_name = "\u{1}?ApplyGain@GainProcessor@vraudio@@QEAAXMAEBVChannelView@2@PEAV32@_N@Z"]
            pub fn GainProcessor_ApplyGain(
                this: *mut root::vraudio::GainProcessor,
                target_gain: f32,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
                accumulate_output: bool,
            );
        }
        extern "C" {
            /// Returns the |current_gain_| value.
            /// ///
            /// /// @return Current gain applied by the |GainProcessor|.
            #[link_name = "\u{1}?GetGain@GainProcessor@vraudio@@QEBAMXZ"]
            pub fn GainProcessor_GetGain(this: *const root::vraudio::GainProcessor) -> f32;
        }
        extern "C" {
            /// Resets the gain processor to a new gain factor.
            /// ///
            /// /// @param gain Gain value.
            #[link_name = "\u{1}?Reset@GainProcessor@vraudio@@QEAAXM@Z"]
            pub fn GainProcessor_Reset(this: *mut root::vraudio::GainProcessor, gain: f32);
        }
        extern "C" {
            /// Default constructor keeps the gain state uninitialized. The first call to
            /// /// |ApplyGain| sets the internal gain state.
            #[link_name = "\u{1}??0GainProcessor@vraudio@@QEAA@XZ"]
            pub fn GainProcessor_GainProcessor(this: *mut root::vraudio::GainProcessor);
        }
        extern "C" {
            /// Constructs |GainProcessor| with some initial gain value.
            /// ///
            /// /// @param initial_gain Gain value used as starting point for first processing
            /// ///   period's gain ramping.
            #[link_name = "\u{1}??0GainProcessor@vraudio@@QEAA@M@Z"]
            pub fn GainProcessor_GainProcessor1(
                this: *mut root::vraudio::GainProcessor,
                initial_gain: f32,
            );
        }
        impl GainProcessor {
            #[inline]
            pub unsafe fn ApplyGain(
                &mut self,
                target_gain: f32,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
                accumulate_output: bool,
            ) {
                GainProcessor_ApplyGain(self, target_gain, input, output, accumulate_output)
            }
            #[inline]
            pub unsafe fn GetGain(&self) -> f32 {
                GainProcessor_GetGain(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self, gain: f32) {
                GainProcessor_Reset(self, gain)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GainProcessor_GainProcessor(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(initial_gain: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GainProcessor_GainProcessor1(&mut __bindgen_tmp, initial_gain);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct GainMixer {
            /// Number of channels.
            pub num_channels_: usize,
            /// Output buffer (accumulator).
            pub output_: root::vraudio::AudioBuffer,
            /// Denotes whether the accumulator has processed any inputs or not.
            pub is_empty_: bool,
            /// Scale and accumulation processors, one per channel for each source.
            pub source_gain_processors_: [u64; 8usize],
        }
        /// Comprises one |GainProcessor| per channel of a source and a boolean to
        /// /// denote whether that source is active.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct GainMixer_GainProcessors {
            /// Bool to signify if a given source is still passing data to a processor.
            pub processors_active: bool,
            /// Scale and accumulation processors, one per channel for each source.
            pub processors: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_GainMixer_GainProcessors() {
            assert_eq!(
                ::std::mem::size_of::<GainMixer_GainProcessors>(),
                32usize,
                concat!("Size of: ", stringify!(GainMixer_GainProcessors))
            );
            assert_eq!(
                ::std::mem::align_of::<GainMixer_GainProcessors>(),
                8usize,
                concat!("Alignment of ", stringify!(GainMixer_GainProcessors))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixer_GainProcessors>())).processors_active
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer_GainProcessors),
                    "::",
                    stringify!(processors_active)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixer_GainProcessors>())).processors as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer_GainProcessors),
                    "::",
                    stringify!(processors)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0GainProcessors@GainMixer@vraudio@@QEAA@_K@Z"]
            pub fn GainMixer_GainProcessors_GainProcessors(
                this: *mut root::vraudio::GainMixer_GainProcessors,
                num_channels: usize,
            );
        }
        impl GainMixer_GainProcessors {
            #[inline]
            pub unsafe fn new(num_channels: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GainMixer_GainProcessors_GainProcessors(&mut __bindgen_tmp, num_channels);
                __bindgen_tmp
            }
        }
        #[test]
        fn bindgen_test_layout_GainMixer() {
            assert_eq!(
                ::std::mem::size_of::<GainMixer>(),
                152usize,
                concat!("Size of: ", stringify!(GainMixer))
            );
            assert_eq!(
                ::std::mem::align_of::<GainMixer>(),
                8usize,
                concat!("Alignment of ", stringify!(GainMixer))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GainMixer>())).num_channels_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer),
                    "::",
                    stringify!(num_channels_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GainMixer>())).output_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer),
                    "::",
                    stringify!(output_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GainMixer>())).is_empty_ as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer),
                    "::",
                    stringify!(is_empty_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixer>())).source_gain_processors_ as *const _
                        as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixer),
                    "::",
                    stringify!(source_gain_processors_)
                )
            );
        }
        extern "C" {
            /// Adds a separately scaled version of each channel of the input buffer to the
            /// /// output buffer's corresponding channels.
            /// ///
            /// /// @param input Input buffer to be added.
            /// /// @param gains Gains to be applied to the buffers channels. Must be equal in
            /// ///     length to the number of channels in |input|.
            #[link_name = "\u{1}?AddInput@GainMixer@vraudio@@QEAAXAEBVAudioBuffer@2@AEBV?$vector@MV?$allocator@M@std@@@std@@@Z"]
            pub fn GainMixer_AddInput(
                this: *mut root::vraudio::GainMixer,
                input: *const root::vraudio::AudioBuffer,
                gains: *const [u64; 3usize],
            );
        }
        extern "C" {
            /// Adds a single input channel to each of the output buffer's channels, with
            /// /// a separate gain applied to the input channel per output channel.
            /// ///
            /// /// @param input Input channel to be added.
            /// /// @param source_id Identifier corresponding to the input.
            /// /// @param gains Gains to be applied to the buffers channels. Must be equal in
            /// ///     length to the number of channels in the output buffer.
            #[link_name = "\u{1}?AddInputChannel@GainMixer@vraudio@@QEAAXAEBVChannelView@2@HAEBV?$vector@MV?$allocator@M@std@@@std@@@Z"]
            pub fn GainMixer_AddInputChannel(
                this: *mut root::vraudio::GainMixer,
                input: *const root::vraudio::AudioBuffer_Channel,
                source_id: root::vraudio::SourceId,
                gains: *const [u64; 3usize],
            );
        }
        extern "C" {
            /// Returns a pointer to the accumulator.
            /// ///
            /// /// @return Pointer to the processed (mixed) output buffer, or nullptr if no
            /// ///     input has been added to the accumulator.
            #[link_name = "\u{1}?GetOutput@GainMixer@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn GainMixer_GetOutput(
                this: *const root::vraudio::GainMixer,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Resets the state of the accumulator.
            #[link_name = "\u{1}?Reset@GainMixer@vraudio@@QEAAXXZ"]
            pub fn GainMixer_Reset(this: *mut root::vraudio::GainMixer);
        }
        extern "C" {
            #[link_name = "\u{1}??0GainMixer@vraudio@@QEAA@_K0@Z"]
            pub fn GainMixer_GainMixer(
                this: *mut root::vraudio::GainMixer,
                num_channels: usize,
                frames_per_buffer: usize,
            );
        }
        impl GainMixer {
            #[inline]
            pub unsafe fn AddInput(
                &mut self,
                input: *const root::vraudio::AudioBuffer,
                gains: *const [u64; 3usize],
            ) {
                GainMixer_AddInput(self, input, gains)
            }
            #[inline]
            pub unsafe fn AddInputChannel(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
                source_id: root::vraudio::SourceId,
                gains: *const [u64; 3usize],
            ) {
                GainMixer_AddInputChannel(self, input, source_id, gains)
            }
            #[inline]
            pub unsafe fn GetOutput(&self) -> *const root::vraudio::AudioBuffer {
                GainMixer_GetOutput(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self) {
                GainMixer_Reset(self)
            }
            #[inline]
            pub unsafe fn new(num_channels: usize, frames_per_buffer: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GainMixer_GainMixer(&mut __bindgen_tmp, num_channels, frames_per_buffer);
                __bindgen_tmp
            }
        }
        /// Node that accepts single mono sound object buffer as input and encodes it
        /// into an Ambisonic sound field.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct AmbisonicMixingEncoderNode {
            pub _base: root::vraudio::ProcessingNode,
            pub system_settings_: *const root::vraudio::SystemSettings,
            pub lookup_table_: *const root::vraudio::AmbisonicLookupTable,
            /// Ambisonic order of encoded sources.
            pub ambisonic_order_: ::std::os::raw::c_int,
            /// |GainMixer| instance.
            pub gain_mixer_: root::vraudio::GainMixer,
            /// Encoding coefficient values to be applied to encode the input.
            pub coefficients_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_AmbisonicMixingEncoderNode() {
            assert_eq!(
                ::std::mem::size_of::<AmbisonicMixingEncoderNode>(),
                384usize,
                concat!("Size of: ", stringify!(AmbisonicMixingEncoderNode))
            );
            assert_eq!(
                ::std::mem::align_of::<AmbisonicMixingEncoderNode>(),
                8usize,
                concat!("Alignment of ", stringify!(AmbisonicMixingEncoderNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicMixingEncoderNode>())).system_settings_
                        as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicMixingEncoderNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicMixingEncoderNode>())).lookup_table_ as *const _
                        as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicMixingEncoderNode),
                    "::",
                    stringify!(lookup_table_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicMixingEncoderNode>())).ambisonic_order_
                        as *const _ as usize
                },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicMixingEncoderNode),
                    "::",
                    stringify!(ambisonic_order_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicMixingEncoderNode>())).gain_mixer_ as *const _
                        as usize
                },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicMixingEncoderNode),
                    "::",
                    stringify!(gain_mixer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AmbisonicMixingEncoderNode>())).coefficients_ as *const _
                        as usize
                },
                360usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AmbisonicMixingEncoderNode),
                    "::",
                    stringify!(coefficients_)
                )
            );
        }
        extern "C" {
            /// Initializes AmbisonicMixingEncoderNode class.
            /// ///
            /// /// @param system_settings Global system configuration.
            /// /// @param lookup_table Ambisonic encoding lookup table.
            /// /// @param ambisonic_order Order of Ambisonic sources.
            #[link_name = "\u{1}??0AmbisonicMixingEncoderNode@vraudio@@QEAA@AEBVSystemSettings@1@AEBVAmbisonicLookupTable@1@H@Z"]
            pub fn AmbisonicMixingEncoderNode_AmbisonicMixingEncoderNode(
                this: *mut root::vraudio::AmbisonicMixingEncoderNode,
                system_settings: *const root::vraudio::SystemSettings,
                lookup_table: *const root::vraudio::AmbisonicLookupTable,
                ambisonic_order: ::std::os::raw::c_int,
            );
        }
        impl AmbisonicMixingEncoderNode {
            #[inline]
            pub unsafe fn new(
                system_settings: *const root::vraudio::SystemSettings,
                lookup_table: *const root::vraudio::AmbisonicLookupTable,
                ambisonic_order: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AmbisonicMixingEncoderNode_AmbisonicMixingEncoderNode(
                    &mut __bindgen_tmp,
                    system_settings,
                    lookup_table,
                    ambisonic_order,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@AmbisonicMixingEncoderNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn AmbisonicMixingEncoderNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Audio source node that outputs data via the AudioProcess() method.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct SourceNode {
            pub _base: root::vraudio::Node,
            pub _base_1: root::vraudio::PublisherNode,
            /// Output stream to write processed data to.
            pub output_stream_: root::vraudio::Node_Output,
            /// Flag indicating if this source node can be removed.
            pub end_of_stream_: u8,
        }
        pub type SourceNode_PublisherNodeType = root::vraudio::PublisherNode;
        #[test]
        fn bindgen_test_layout_SourceNode() {
            assert_eq!(
                ::std::mem::size_of::<SourceNode>(),
                88usize,
                concat!("Size of: ", stringify!(SourceNode))
            );
            assert_eq!(
                ::std::mem::align_of::<SourceNode>(),
                8usize,
                concat!("Alignment of ", stringify!(SourceNode))
            );
        }
        extern "C" {
            /// Marks this node as being out of data and to be removed during the next
            /// /// clean-up cycle.
            #[link_name = "\u{1}?MarkEndOfStream@SourceNode@vraudio@@QEAAXXZ"]
            pub fn SourceNode_MarkEndOfStream(this: *mut root::vraudio::SourceNode);
        }
        extern "C" {
            #[link_name = "\u{1}??0SourceNode@vraudio@@QEAA@XZ"]
            pub fn SourceNode_SourceNode(this: *mut root::vraudio::SourceNode);
        }
        impl SourceNode {
            #[inline]
            pub unsafe fn MarkEndOfStream(&mut self) {
                SourceNode_MarkEndOfStream(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SourceNode_SourceNode(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Node implementation.
            #[link_name = "\u{1}?Process@SourceNode@vraudio@@UEAAXXZ"]
            pub fn SourceNode_Process(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?CleanUp@SourceNode@vraudio@@UEAA_NXZ"]
            pub fn SourceNode_CleanUp(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            /// PublisherNode<OutputType> implementation.
            #[link_name = "\u{1}?GetSharedNodePtr@SourceNode@vraudio@@UEAA?AV?$shared_ptr@VNode@vraudio@@@std@@XZ"]
            pub fn SourceNode_GetSharedNodePtr(this: *mut ::std::os::raw::c_void) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}?GetOutput@SourceNode@vraudio@@UEAAPEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@2@XZ"]
            pub fn SourceNode_GetOutput(
                this: *mut ::std::os::raw::c_void,
            ) -> *mut root::vraudio::Node_Output;
        }
        /// Node that sets the |AudioBuffer| of a source. This class is *not*
        /// thread-safe and calls to this class must be synchronized with the graph
        /// processing.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct BufferedSourceNode {
            pub _base: root::vraudio::SourceNode,
            /// Source id.
            pub source_id_: root::vraudio::SourceId,
            /// Input audio buffer.
            pub input_audio_buffer_: root::vraudio::AudioBuffer,
            /// Flag indicating if an new audio buffer has been set via
            /// /// |GetMutableAudioBufferAndSetNewBufferFlag|.
            pub new_buffer_flag_: bool,
        }
        #[test]
        fn bindgen_test_layout_BufferedSourceNode() {
            assert_eq!(
                ::std::mem::size_of::<BufferedSourceNode>(),
                176usize,
                concat!("Size of: ", stringify!(BufferedSourceNode))
            );
            assert_eq!(
                ::std::mem::align_of::<BufferedSourceNode>(),
                8usize,
                concat!("Alignment of ", stringify!(BufferedSourceNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<BufferedSourceNode>())).source_id_ as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferedSourceNode),
                    "::",
                    stringify!(source_id_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<BufferedSourceNode>())).input_audio_buffer_ as *const _
                        as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferedSourceNode),
                    "::",
                    stringify!(input_audio_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<BufferedSourceNode>())).new_buffer_flag_ as *const _
                        as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferedSourceNode),
                    "::",
                    stringify!(new_buffer_flag_)
                )
            );
        }
        extern "C" {
            /// Returns a mutable pointer to the internal |AudioBuffer| and sets a flag to
            /// /// process the buffer in the next graph processing iteration. Calls to this
            /// /// method must be synchronized with the audio graph processing.
            /// ///
            /// /// @return Mutable audio buffer pointer.
            #[link_name = "\u{1}?GetMutableAudioBufferAndSetNewBufferFlag@BufferedSourceNode@vraudio@@QEAAPEAVAudioBuffer@2@XZ"]
            pub fn BufferedSourceNode_GetMutableAudioBufferAndSetNewBufferFlag(
                this: *mut root::vraudio::BufferedSourceNode,
            ) -> *mut root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Constructor.
            /// ///
            /// /// @param source_id Source id.
            /// /// @param num_channel Number of channels in output buffers.
            #[link_name = "\u{1}??0BufferedSourceNode@vraudio@@QEAA@H_K0@Z"]
            pub fn BufferedSourceNode_BufferedSourceNode(
                this: *mut root::vraudio::BufferedSourceNode,
                source_id: root::vraudio::SourceId,
                num_channels: usize,
                frames_per_buffer: usize,
            );
        }
        impl BufferedSourceNode {
            #[inline]
            pub unsafe fn GetMutableAudioBufferAndSetNewBufferFlag(
                &mut self,
            ) -> *mut root::vraudio::AudioBuffer {
                BufferedSourceNode_GetMutableAudioBufferAndSetNewBufferFlag(self)
            }
            #[inline]
            pub unsafe fn new(
                source_id: root::vraudio::SourceId,
                num_channels: usize,
                frames_per_buffer: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                BufferedSourceNode_BufferedSourceNode(
                    &mut __bindgen_tmp,
                    source_id,
                    num_channels,
                    frames_per_buffer,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Implements SourceNode.
            #[link_name = "\u{1}?AudioProcess@BufferedSourceNode@vraudio@@MEAAPEBVAudioBuffer@2@XZ"]
            pub fn BufferedSourceNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Node that accepts multiple input buffers, calculates and applies a gain
        /// value to each buffer based upon the given |AttenuationType| and then mixes
        /// the results together.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct GainMixerNode {
            pub _base: root::vraudio::ProcessingNode,
            /// Flag indicating the mute status.
            pub mute_enabled_: bool,
            /// Gain attenuation type.
            pub attenuation_type_: root::vraudio::AttenuationType,
            /// Gain mixer.
            pub gain_mixer_: root::vraudio::GainMixer,
            /// Global system settings.
            pub system_settings_: *const root::vraudio::SystemSettings,
        }
        #[test]
        fn bindgen_test_layout_GainMixerNode() {
            assert_eq!(
                ::std::mem::size_of::<GainMixerNode>(),
                352usize,
                concat!("Size of: ", stringify!(GainMixerNode))
            );
            assert_eq!(
                ::std::mem::align_of::<GainMixerNode>(),
                8usize,
                concat!("Alignment of ", stringify!(GainMixerNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixerNode>())).mute_enabled_ as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixerNode),
                    "::",
                    stringify!(mute_enabled_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixerNode>())).attenuation_type_ as *const _ as usize
                },
                188usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixerNode),
                    "::",
                    stringify!(attenuation_type_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixerNode>())).gain_mixer_ as *const _ as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixerNode),
                    "::",
                    stringify!(gain_mixer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GainMixerNode>())).system_settings_ as *const _ as usize
                },
                344usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GainMixerNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
        }
        extern "C" {
            /// Mute the mixer node by skipping the audio processing and outputting nullptr
            /// /// buffers.
            #[link_name = "\u{1}?SetMute@GainMixerNode@vraudio@@QEAAX_N@Z"]
            pub fn GainMixerNode_SetMute(
                this: *mut root::vraudio::GainMixerNode,
                mute_enabled: bool,
            );
        }
        extern "C" {
            /// Constructs |GainMixerNode| with given gain calculation method.
            /// ///
            /// /// @param attenuation_type Gain attenuation type to be used.
            /// /// @param system_settings Global system settings.
            /// /// @param num_channels Number of channels.
            #[link_name = "\u{1}??0GainMixerNode@vraudio@@QEAA@AEBW4AttenuationType@1@AEBVSystemSettings@1@_K@Z"]
            pub fn GainMixerNode_GainMixerNode(
                this: *mut root::vraudio::GainMixerNode,
                attenuation_type: *const root::vraudio::AttenuationType,
                system_settings: *const root::vraudio::SystemSettings,
                num_channels: usize,
            );
        }
        impl GainMixerNode {
            #[inline]
            pub unsafe fn SetMute(&mut self, mute_enabled: bool) {
                GainMixerNode_SetMute(self, mute_enabled)
            }
            #[inline]
            pub unsafe fn new(
                attenuation_type: *const root::vraudio::AttenuationType,
                system_settings: *const root::vraudio::SystemSettings,
                num_channels: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GainMixerNode_GainMixerNode(
                    &mut __bindgen_tmp,
                    attenuation_type,
                    system_settings,
                    num_channels,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Node implementation.
            #[link_name = "\u{1}?CleanUp@GainMixerNode@vraudio@@UEAA_NXZ"]
            pub fn GainMixerNode_CleanUp(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@GainMixerNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn GainMixerNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Accepts multiple input buffers and outputs a downmix to a single output
        /// buffer. All input buffers must have the same number of frames per buffer, the
        /// output will have the target number of channels regardless of the input number
        /// of channels.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct Mixer {
            /// Output buffer (accumulator).
            pub output_: root::vraudio::AudioBuffer,
            /// Denotes whether the accumulator has processed any inputs or not.
            pub is_empty_: bool,
        }
        #[test]
        fn bindgen_test_layout_Mixer() {
            assert_eq!(
                ::std::mem::size_of::<Mixer>(),
                80usize,
                concat!("Size of: ", stringify!(Mixer))
            );
            assert_eq!(
                ::std::mem::align_of::<Mixer>(),
                8usize,
                concat!("Alignment of ", stringify!(Mixer))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Mixer>())).output_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Mixer),
                    "::",
                    stringify!(output_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Mixer>())).is_empty_ as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Mixer),
                    "::",
                    stringify!(is_empty_)
                )
            );
        }
        extern "C" {
            /// Adds an input buffer to the mixer, updates the output buffer accordingly.
            /// ///
            /// /// @param input Input buffer to be added.
            #[link_name = "\u{1}?AddInput@Mixer@vraudio@@QEAAXAEBVAudioBuffer@2@@Z"]
            pub fn Mixer_AddInput(
                this: *mut root::vraudio::Mixer,
                input: *const root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            /// Returns a pointer to the accumulator.
            /// ///
            /// /// @return Pointer to the processed (mixed) output buffer, or nullptr if no
            /// ///     input has been added to the accumulator.
            #[link_name = "\u{1}?GetOutput@Mixer@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn Mixer_GetOutput(
                this: *const root::vraudio::Mixer,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Resets the state of the accumulator.
            #[link_name = "\u{1}?Reset@Mixer@vraudio@@QEAAXXZ"]
            pub fn Mixer_Reset(this: *mut root::vraudio::Mixer);
        }
        extern "C" {
            /// Constructor.
            /// ///
            /// /// @param target_num_channels Target number of channels in accumulator buffer.
            /// /// @param frames_per_buffer Number of frames in accumulator buffer.
            #[link_name = "\u{1}??0Mixer@vraudio@@QEAA@_K0@Z"]
            pub fn Mixer_Mixer(
                this: *mut root::vraudio::Mixer,
                target_num_channels: usize,
                frames_per_buffer: usize,
            );
        }
        impl Mixer {
            #[inline]
            pub unsafe fn AddInput(&mut self, input: *const root::vraudio::AudioBuffer) {
                Mixer_AddInput(self, input)
            }
            #[inline]
            pub unsafe fn GetOutput(&self) -> *const root::vraudio::AudioBuffer {
                Mixer_GetOutput(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self) {
                Mixer_Reset(self)
            }
            #[inline]
            pub unsafe fn new(target_num_channels: usize, frames_per_buffer: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Mixer_Mixer(&mut __bindgen_tmp, target_num_channels, frames_per_buffer);
                __bindgen_tmp
            }
        }
        /// Accepts multiple input buffers and outputs a downmix to a single output
        /// buffer. All input buffers must have the same number of channels and the same
        /// number of frames per buffer.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct MixerNode {
            pub _base: root::vraudio::ProcessingNode,
            pub num_channels_: usize,
            pub mixer_: root::vraudio::Mixer,
        }
        #[test]
        fn bindgen_test_layout_MixerNode() {
            assert_eq!(
                ::std::mem::size_of::<MixerNode>(),
                272usize,
                concat!("Size of: ", stringify!(MixerNode))
            );
            assert_eq!(
                ::std::mem::align_of::<MixerNode>(),
                8usize,
                concat!("Alignment of ", stringify!(MixerNode))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MixerNode>())).num_channels_ as *const _ as usize },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MixerNode),
                    "::",
                    stringify!(num_channels_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MixerNode>())).mixer_ as *const _ as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MixerNode),
                    "::",
                    stringify!(mixer_)
                )
            );
        }
        extern "C" {
            /// Returns the current output buffer of the mixer.
            /// ///
            /// /// @return Output audio buffer.
            #[link_name = "\u{1}?GetOutputBuffer@MixerNode@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn MixerNode_GetOutputBuffer(
                this: *const root::vraudio::MixerNode,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}??0MixerNode@vraudio@@QEAA@AEBVSystemSettings@1@_K@Z"]
            pub fn MixerNode_MixerNode(
                this: *mut root::vraudio::MixerNode,
                system_settings: *const root::vraudio::SystemSettings,
                num_channels: usize,
            );
        }
        impl MixerNode {
            #[inline]
            pub unsafe fn GetOutputBuffer(&self) -> *const root::vraudio::AudioBuffer {
                MixerNode_GetOutputBuffer(self)
            }
            #[inline]
            pub unsafe fn new(
                system_settings: *const root::vraudio::SystemSettings,
                num_channels: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                MixerNode_MixerNode(&mut __bindgen_tmp, system_settings, num_channels);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Node implementation.
            #[link_name = "\u{1}?CleanUp@MixerNode@vraudio@@UEAA_NXZ"]
            pub fn MixerNode_CleanUp(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@MixerNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn MixerNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Rotator for first order ambisonic soundfields. It supports ACN channel
        /// ordering and SN3D normalization (AmbiX).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq)]
        pub struct FoaRotator {
            /// Current rotation which is used in the interpolation process in order to
            /// /// perform a smooth rotation. Initialized with an identity matrix.
            pub current_rotation_: root::vraudio::WorldRotation,
            /// Preallocation of temporary variables used during rotation.
            pub temp_audio_position_: root::vraudio::AudioPosition,
            pub temp_world_position_: root::vraudio::WorldPosition,
            pub temp_rotated_audio_position_: root::vraudio::AudioPosition,
            pub temp_rotated_world_position_: root::vraudio::WorldPosition,
        }
        #[test]
        fn bindgen_test_layout_FoaRotator() {
            assert_eq!(
                ::std::mem::size_of::<FoaRotator>(),
                64usize,
                concat!("Size of: ", stringify!(FoaRotator))
            );
            assert_eq!(
                ::std::mem::align_of::<FoaRotator>(),
                4usize,
                concat!("Alignment of ", stringify!(FoaRotator))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FoaRotator>())).current_rotation_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FoaRotator),
                    "::",
                    stringify!(current_rotation_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FoaRotator>())).temp_audio_position_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FoaRotator),
                    "::",
                    stringify!(temp_audio_position_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FoaRotator>())).temp_world_position_ as *const _ as usize
                },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FoaRotator),
                    "::",
                    stringify!(temp_world_position_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FoaRotator>())).temp_rotated_audio_position_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FoaRotator),
                    "::",
                    stringify!(temp_rotated_audio_position_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FoaRotator>())).temp_rotated_world_position_ as *const _
                        as usize
                },
                52usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FoaRotator),
                    "::",
                    stringify!(temp_rotated_world_position_)
                )
            );
        }
        extern "C" {
            /// @param target_rotation Target rotation to be applied to the input buffer.
            /// /// @param input First order soundfield input buffer to be rotated.
            /// /// @param output Pointer to output buffer.
            /// /// @return True if rotation has been applied.
            #[link_name = "\u{1}?Process@FoaRotator@vraudio@@QEAA_NAEBVWorldRotation@2@AEBVAudioBuffer@2@PEAV42@@Z"]
            pub fn FoaRotator_Process(
                this: *mut root::vraudio::FoaRotator,
                target_rotation: *const root::vraudio::WorldRotation,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) -> bool;
        }
        impl FoaRotator {
            #[inline]
            pub unsafe fn Process(
                &mut self,
                target_rotation: *const root::vraudio::WorldRotation,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) -> bool {
                FoaRotator_Process(self, target_rotation, input, output)
            }
        }
        /// This implementation is not thread safe. The ClearBuffer() and InsertData()
        /// functions should not be called by a seperate thread during GetDelayedData().
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct DelayFilter {
            /// Maximum length of the delay to be applied (in samples).
            pub max_delay_length_: usize,
            /// Number of frames in each AudioBuffer input/output.
            pub frames_per_buffer_: usize,
            /// The delay line holding all of the delayed samples.
            pub delay_line_: u64,
            /// Position in the delay line to begin writing to.
            pub write_cursor_: usize,
        }
        #[test]
        fn bindgen_test_layout_DelayFilter() {
            assert_eq!(
                ::std::mem::size_of::<DelayFilter>(),
                32usize,
                concat!("Size of: ", stringify!(DelayFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<DelayFilter>(),
                8usize,
                concat!("Alignment of ", stringify!(DelayFilter))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<DelayFilter>())).max_delay_length_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DelayFilter),
                    "::",
                    stringify!(max_delay_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<DelayFilter>())).frames_per_buffer_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DelayFilter),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DelayFilter>())).delay_line_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DelayFilter),
                    "::",
                    stringify!(delay_line_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<DelayFilter>())).write_cursor_ as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DelayFilter),
                    "::",
                    stringify!(write_cursor_)
                )
            );
        }
        extern "C" {
            /// Sets the maximum delay length. It will allocate more space in the
            /// /// |delay_line_| if the new |max_delay_length| is more than doubled.
            /// ///
            /// /// @param max_delay_length New maximum delay in samples.
            #[link_name = "\u{1}?SetMaximumDelay@DelayFilter@vraudio@@QEAAX_K@Z"]
            pub fn DelayFilter_SetMaximumDelay(
                this: *mut root::vraudio::DelayFilter,
                max_delay_length: usize,
            );
        }
        extern "C" {
            /// Copies an |AudioBuffer::Channel| of data to the delay line.
            /// ///
            /// /// @param input Input data.
            #[link_name = "\u{1}?InsertData@DelayFilter@vraudio@@QEAAXAEBVChannelView@2@@Z"]
            pub fn DelayFilter_InsertData(
                this: *mut root::vraudio::DelayFilter,
                input: *const root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Fills an |AudioBuffer::Channel| with data delayed by a specified amount
            /// /// less than or equal to the delay line's set |max_delay_length_|.
            /// ///
            /// /// @param delay_samples Requested delay to the data extraced from the delay
            /// ///     line. Must be less than or equal to |max_delay_length_|.
            /// /// @param buffer Pointer to the output data, i.e., delayed input data.
            #[link_name = "\u{1}?GetDelayedData@DelayFilter@vraudio@@QEAAX_KPEAVChannelView@2@@Z"]
            pub fn DelayFilter_GetDelayedData(
                this: *mut root::vraudio::DelayFilter,
                delay_samples: usize,
                buffer: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Constructs a DelayFilter.
            /// ///
            /// /// @param max_delay_length Maximum number of samples the input should be
            /// ///     delayed by.
            /// /// @param frames_per_buffer Number of frames in each processed buffer.
            #[link_name = "\u{1}??0DelayFilter@vraudio@@QEAA@_K0@Z"]
            pub fn DelayFilter_DelayFilter(
                this: *mut root::vraudio::DelayFilter,
                max_delay_length: usize,
                frames_per_buffer: usize,
            );
        }
        impl DelayFilter {
            #[inline]
            pub unsafe fn SetMaximumDelay(&mut self, max_delay_length: usize) {
                DelayFilter_SetMaximumDelay(self, max_delay_length)
            }
            #[inline]
            pub unsafe fn InsertData(&mut self, input: *const root::vraudio::AudioBuffer_Channel) {
                DelayFilter_InsertData(self, input)
            }
            #[inline]
            pub unsafe fn GetDelayedData(
                &mut self,
                delay_samples: usize,
                buffer: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                DelayFilter_GetDelayedData(self, delay_samples, buffer)
            }
            #[inline]
            pub unsafe fn new(max_delay_length: usize, frames_per_buffer: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                DelayFilter_DelayFilter(&mut __bindgen_tmp, max_delay_length, frames_per_buffer);
                __bindgen_tmp
            }
        }
        /// Class representing a mono pole filter. This class also performs filtering.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MonoPoleFilter {
            /// The previous frame computed by the filter.
            pub previous_output_: f32,
            /// Represents and maintains the state of the filter in terms of its
            /// /// transfer function coefficient.
            pub coefficient_: f32,
        }
        #[test]
        fn bindgen_test_layout_MonoPoleFilter() {
            assert_eq!(
                ::std::mem::size_of::<MonoPoleFilter>(),
                8usize,
                concat!("Size of: ", stringify!(MonoPoleFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<MonoPoleFilter>(),
                4usize,
                concat!("Alignment of ", stringify!(MonoPoleFilter))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MonoPoleFilter>())).previous_output_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MonoPoleFilter),
                    "::",
                    stringify!(previous_output_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MonoPoleFilter>())).coefficient_ as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MonoPoleFilter),
                    "::",
                    stringify!(coefficient_)
                )
            );
        }
        extern "C" {
            /// Filter method for use with AudioBuffer::Channel.
            /// ///
            /// /// @param input |AudioBuffer::Channel| of input to be processed.
            /// /// @param output Pointer to output |AudioBuffer::Channel|.
            /// /// @return Returns false if the filter has an allpass configuration. This
            /// ///     helps to avoid copies whenever the output is expected to be identical
            /// ///     to the input.
            #[link_name = "\u{1}?Filter@MonoPoleFilter@vraudio@@QEAA_NAEBVChannelView@2@PEAV32@@Z"]
            pub fn MonoPoleFilter_Filter(
                this: *mut root::vraudio::MonoPoleFilter,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool;
        }
        extern "C" {
            /// Sets the filter's coefficent.
            /// ///
            /// /// @param coefficient A mono pole filter coefficient.
            #[link_name = "\u{1}?SetCoefficient@MonoPoleFilter@vraudio@@QEAAXM@Z"]
            pub fn MonoPoleFilter_SetCoefficient(
                this: *mut root::vraudio::MonoPoleFilter,
                coefficient: f32,
            );
        }
        extern "C" {
            /// Constructs a |MonoPoleFilter| given a single coefficient.
            /// ///
            /// /// @param coefficient A single coefficient between 0.0f and 1.0f.
            #[link_name = "\u{1}??0MonoPoleFilter@vraudio@@QEAA@M@Z"]
            pub fn MonoPoleFilter_MonoPoleFilter(
                this: *mut root::vraudio::MonoPoleFilter,
                coefficient: f32,
            );
        }
        impl MonoPoleFilter {
            #[inline]
            pub unsafe fn Filter(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool {
                MonoPoleFilter_Filter(self, input, output)
            }
            #[inline]
            pub unsafe fn SetCoefficient(&mut self, coefficient: f32) {
                MonoPoleFilter_SetCoefficient(self, coefficient)
            }
            #[inline]
            pub unsafe fn new(coefficient: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                MonoPoleFilter_MonoPoleFilter(&mut __bindgen_tmp, coefficient);
                __bindgen_tmp
            }
        }
        /// Describes a room reflection that contains information on its time of arrival
        /// and magnitude.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Reflection {
            /// Time of arrival of the reflection in seconds.
            pub delay_time_seconds: f32,
            /// Magnitude of the reflection.
            pub magnitude: f32,
        }
        #[test]
        fn bindgen_test_layout_Reflection() {
            assert_eq!(
                ::std::mem::size_of::<Reflection>(),
                8usize,
                concat!("Size of: ", stringify!(Reflection))
            );
            assert_eq!(
                ::std::mem::align_of::<Reflection>(),
                4usize,
                concat!("Alignment of ", stringify!(Reflection))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Reflection>())).delay_time_seconds as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reflection),
                    "::",
                    stringify!(delay_time_seconds)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Reflection>())).magnitude as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reflection),
                    "::",
                    stringify!(magnitude)
                )
            );
        }
        /// The input consists of a mono mix of all the sound objects in the system. The
        /// reflections are assumed to be aligned with the aabb axes and thus the first
        /// order ambisonic axes.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReflectionsProcessor {
            /// System sampling rate.
            pub sample_rate_: ::std::os::raw::c_int,
            /// System number of frames per buffer.
            pub frames_per_buffer_: usize,
            /// Maximum allowed delay time for a reflection (in samples).
            pub max_delay_samples_: usize,
            /// Low pass filter to be applied to input signal.
            pub low_pass_filter_: root::vraudio::MonoPoleFilter,
            /// Audio buffer to store mono low pass filtered buffers during processing.
            pub temp_mono_buffer_: root::vraudio::AudioBuffer,
            /// Audio buffers to store FOA reflections buffers during crossfading.
            pub current_reflection_buffer_: root::vraudio::AudioBuffer,
            pub target_reflection_buffer_: root::vraudio::AudioBuffer,
            /// Target reflections filled with new data when |Update| is called.
            pub target_reflections_: [u64; 3usize],
            /// Indicates whether relfections have been updated and a crossfade is needed.
            pub crossfade_: bool,
            /// Buffer crossfader to apply linear crossfade during reflections update.
            pub crossfader_: root::vraudio::BufferCrossfader,
            /// Number of frames needed to keep processing on empty input signal.
            pub num_frames_to_process_on_empty_input_: usize,
            /// Number of samples of delay to be applied for each reflection.
            pub delays_: [u64; 3usize],
            /// Delay filter to delay the incoming buffer.
            pub delay_filter_: root::vraudio::DelayFilter,
            /// Delay buffer used to store delayed reflections before scaling and encoding.
            pub delay_buffer_: root::vraudio::AudioBuffer,
            /// Gains to be applied for each reflection.
            pub gains_: [u64; 3usize],
            /// |GainProcessor|s to apply |gains_|.
            pub gain_processors_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_ReflectionsProcessor() {
            assert_eq!(
                ::std::mem::size_of::<ReflectionsProcessor>(),
                536usize,
                concat!("Size of: ", stringify!(ReflectionsProcessor))
            );
            assert_eq!(
                ::std::mem::align_of::<ReflectionsProcessor>(),
                8usize,
                concat!("Alignment of ", stringify!(ReflectionsProcessor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).sample_rate_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(sample_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).frames_per_buffer_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).max_delay_samples_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(max_delay_samples_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).low_pass_filter_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(low_pass_filter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).temp_mono_buffer_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(temp_mono_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).current_reflection_buffer_
                        as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(current_reflection_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).target_reflection_buffer_
                        as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(target_reflection_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).target_reflections_ as *const _
                        as usize
                },
                248usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(target_reflections_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).crossfade_ as *const _ as usize
                },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(crossfade_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).crossfader_ as *const _
                        as usize
                },
                280usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(crossfader_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>()))
                        .num_frames_to_process_on_empty_input_ as *const _
                        as usize
                },
                352usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(num_frames_to_process_on_empty_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).delays_ as *const _ as usize
                },
                360usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(delays_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).delay_filter_ as *const _
                        as usize
                },
                384usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(delay_filter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).delay_buffer_ as *const _
                        as usize
                },
                416usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(delay_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).gains_ as *const _ as usize
                },
                488usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(gains_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsProcessor>())).gain_processors_ as *const _
                        as usize
                },
                512usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsProcessor),
                    "::",
                    stringify!(gain_processors_)
                )
            );
        }
        extern "C" {
            /// Updates reflections according to the new |ReflectionProperties|.
            /// ///
            /// /// @param reflection_properties New reflection properties.
            /// /// @param listener_position New listener position.
            #[link_name = "\u{1}?Update@ReflectionsProcessor@vraudio@@QEAAXAEBUReflectionProperties@2@AEBVWorldPosition@2@@Z"]
            pub fn ReflectionsProcessor_Update(
                this: *mut root::vraudio::ReflectionsProcessor,
                reflection_properties: *const root::vraudio::ReflectionProperties,
                listener_position: *const root::vraudio::WorldPosition,
            );
        }
        extern "C" {
            /// Processes a mono |AudioBuffer| into an ambisonic |AudioBuffer|.
            /// ///
            /// /// @param input Mono input buffer.
            /// /// @param output Ambisonic output buffer.
            #[link_name = "\u{1}?Process@ReflectionsProcessor@vraudio@@QEAAXAEBVAudioBuffer@2@PEAV32@@Z"]
            pub fn ReflectionsProcessor_Process(
                this: *mut root::vraudio::ReflectionsProcessor,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            /// Constructs a |ReflectionsProcessor|.
            /// ///
            /// /// @param sample_rate System sampling rate.
            /// /// @param frames_per_buffer System frames per buffer.
            #[link_name = "\u{1}??0ReflectionsProcessor@vraudio@@QEAA@H_K@Z"]
            pub fn ReflectionsProcessor_ReflectionsProcessor(
                this: *mut root::vraudio::ReflectionsProcessor,
                sample_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
            );
        }
        impl ReflectionsProcessor {
            #[inline]
            pub unsafe fn Update(
                &mut self,
                reflection_properties: *const root::vraudio::ReflectionProperties,
                listener_position: *const root::vraudio::WorldPosition,
            ) {
                ReflectionsProcessor_Update(self, reflection_properties, listener_position)
            }
            #[inline]
            pub unsafe fn Process(
                &mut self,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) {
                ReflectionsProcessor_Process(self, input, output)
            }
            #[inline]
            pub unsafe fn new(
                sample_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ReflectionsProcessor_ReflectionsProcessor(
                    &mut __bindgen_tmp,
                    sample_rate,
                    frames_per_buffer,
                );
                __bindgen_tmp
            }
        }
        /// Node that accepts a single mono buffer as input and outputs an ambisonically
        /// encoded sound field buffer of the mix of all the early room reflections.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReflectionsNode {
            pub _base: root::vraudio::ProcessingNode,
            pub system_settings_: *const root::vraudio::SystemSettings,
            /// First-order-ambisonics rotator to be used to rotate the reflections with
            /// /// respect to the listener's orientation.
            pub foa_rotator_: root::vraudio::FoaRotator,
            /// Processes and encodes reflections into an ambisonic buffer.
            pub reflections_processor_: root::vraudio::ReflectionsProcessor,
            /// Most recently updated reflection properties.
            pub reflection_properties_: root::vraudio::ReflectionProperties,
            /// Most recently updated listener position.
            pub listener_position_: root::vraudio::WorldPosition,
            pub num_frames_processed_on_empty_input_: usize,
            /// Ambisonic output buffer.
            pub output_buffer_: root::vraudio::AudioBuffer,
            /// Silence mono buffer to render reflection tails during the absence of input
            /// /// buffers.
            pub silence_mono_buffer_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_ReflectionsNode() {
            assert_eq!(
                ::std::mem::size_of::<ReflectionsNode>(),
                1032usize,
                concat!("Size of: ", stringify!(ReflectionsNode))
            );
            assert_eq!(
                ::std::mem::align_of::<ReflectionsNode>(),
                8usize,
                concat!("Alignment of ", stringify!(ReflectionsNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).system_settings_ as *const _
                        as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).foa_rotator_ as *const _ as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(foa_rotator_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).reflections_processor_ as *const _
                        as usize
                },
                256usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(reflections_processor_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).reflection_properties_ as *const _
                        as usize
                },
                792usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(reflection_properties_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).listener_position_ as *const _
                        as usize
                },
                864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(listener_position_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).num_frames_processed_on_empty_input_
                        as *const _ as usize
                },
                880usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(num_frames_processed_on_empty_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).output_buffer_ as *const _ as usize
                },
                888usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(output_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReflectionsNode>())).silence_mono_buffer_ as *const _
                        as usize
                },
                960usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReflectionsNode),
                    "::",
                    stringify!(silence_mono_buffer_)
                )
            );
        }
        extern "C" {
            /// Updates the reflections. Depending on whether to use RT60s for reverb
            /// /// according to the global system settings, the reflections are calculated
            /// /// either by the current room properties or the proxy room properties.
            #[link_name = "\u{1}?Update@ReflectionsNode@vraudio@@QEAAXXZ"]
            pub fn ReflectionsNode_Update(this: *mut root::vraudio::ReflectionsNode);
        }
        extern "C" {
            /// Initializes |ReflectionsNode| class.
            /// ///
            /// /// @param system_settings Global system configuration.
            #[link_name = "\u{1}??0ReflectionsNode@vraudio@@QEAA@AEBVSystemSettings@1@@Z"]
            pub fn ReflectionsNode_ReflectionsNode(
                this: *mut root::vraudio::ReflectionsNode,
                system_settings: *const root::vraudio::SystemSettings,
            );
        }
        impl ReflectionsNode {
            #[inline]
            pub unsafe fn Update(&mut self) {
                ReflectionsNode_Update(self)
            }
            #[inline]
            pub unsafe fn new(system_settings: *const root::vraudio::SystemSettings) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ReflectionsNode_ReflectionsNode(&mut __bindgen_tmp, system_settings);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@ReflectionsNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn ReflectionsNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Updater for the |ReverbOnsetCompensator|.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReverbOnsetUpdateProcessor {
            /// System sample rate.
            pub sampling_rate_: ::std::os::raw::c_int,
            /// Current frame position of the reverb tail to be updated.
            pub tail_update_cursor_: usize,
            /// Length of the new reverb tail to be replaced in frames.
            pub tail_length_: usize,
            /// Gain applied to the reverb compensation.
            pub gain_: f32,
            /// Indices of the multiplication factor to be used to create the onset
            /// /// compensation curve at each frequency band.
            pub curve_indices_: [u64; 3usize],
            /// Decay coefficients per each band of the reverb tail, used below 0.15s
            /// /// @48kHz.
            pub pure_decay_coefficients_: [u64; 3usize],
            /// Decay exponential per each band of the reverb tail, used below 0.15s
            /// /// @48kHz.
            pub pure_decay_exponents_: [u64; 3usize],
            /// Temporary buffers used to process the decayed noise per each band.
            pub band_buffer_: root::vraudio::AudioBuffer,
            pub envelope_buffer_: root::vraudio::AudioBuffer,
            /// Pointers to audio buffers owned by the |ReverbOnsetCompensator| storing the
            /// /// constituent curves used to generate the onset compensation envelopes.
            pub base_curves_: *mut root::vraudio::AudioBuffer,
            pub adder_curves_: *mut root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_ReverbOnsetUpdateProcessor() {
            assert_eq!(
                ::std::mem::size_of::<ReverbOnsetUpdateProcessor>(),
                264usize,
                concat!("Size of: ", stringify!(ReverbOnsetUpdateProcessor))
            );
            assert_eq!(
                ::std::mem::align_of::<ReverbOnsetUpdateProcessor>(),
                8usize,
                concat!("Alignment of ", stringify!(ReverbOnsetUpdateProcessor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).sampling_rate_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(sampling_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).tail_update_cursor_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(tail_update_cursor_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).tail_length_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(tail_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).gain_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(gain_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).curve_indices_
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(curve_indices_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).pure_decay_coefficients_
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(pure_decay_coefficients_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).pure_decay_exponents_
                        as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(pure_decay_exponents_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).band_buffer_ as *const _
                        as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(band_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).envelope_buffer_
                        as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(envelope_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).base_curves_ as *const _
                        as usize
                },
                248usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(base_curves_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetUpdateProcessor>())).adder_curves_ as *const _
                        as usize
                },
                256usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetUpdateProcessor),
                    "::",
                    stringify!(adder_curves_)
                )
            );
        }
        extern "C" {
            /// Sets reverberation times in different frequency bands.
            /// ///
            /// /// @param rt60_values |kNumReverbOctaveBands| values denoting the
            /// ///     reverberation decay time to -60dB in octave bands starting at
            /// ///     |kLowestOctaveBand|.
            #[link_name = "\u{1}?SetReverbTimes@ReverbOnsetUpdateProcessor@vraudio@@QEAAXPEBM@Z"]
            pub fn ReverbOnsetUpdateProcessor_SetReverbTimes(
                this: *mut root::vraudio::ReverbOnsetUpdateProcessor,
                rt60_values: *const f32,
            );
        }
        extern "C" {
            /// Processes the next tail update.
            /// ///
            /// /// @param bandpassed_noise_left Pre-computed bandpassed noise buffer.
            /// /// @param bandpassed_noise_right Pre-computed bandpassed noise buffer.
            /// /// @param kernel_channel_left Kernel channel to fill in the processed output.
            /// /// @param kernel_channel_right Kernel channel to fill in the processed output.
            /// /// @return True if the tail update continues.
            #[link_name = "\u{1}?Process@ReverbOnsetUpdateProcessor@vraudio@@QEAA_NAEBV?$vector@VAudioBuffer@vraudio@@V?$allocator@VAudioBuffer@vraudio@@@std@@@std@@0PEAVChannelView@2@1@Z"]
            pub fn ReverbOnsetUpdateProcessor_Process(
                this: *mut root::vraudio::ReverbOnsetUpdateProcessor,
                bandpassed_noise_left: *const [u64; 3usize],
                bandpassed_noise_right: *const [u64; 3usize],
                kernel_channel_left: *mut root::vraudio::AudioBuffer_Channel,
                kernel_channel_right: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool;
        }
        extern "C" {
            /// Constructs a update processor for the sprectral reverb onset compensator.
            /// ///
            /// /// @param frames_per_buffer_ System buffer length in frames.
            /// /// @param sampling_rate System sample rate.
            /// /// @param base_curves Constituent curve used for envelope generation.
            /// /// @param ader_curves Constituent curve used for envelope generation.
            #[link_name = "\u{1}??0ReverbOnsetUpdateProcessor@vraudio@@QEAA@_KHPEAVAudioBuffer@1@1@Z"]
            pub fn ReverbOnsetUpdateProcessor_ReverbOnsetUpdateProcessor(
                this: *mut root::vraudio::ReverbOnsetUpdateProcessor,
                frames_per_buffer: usize,
                sampling_rate: ::std::os::raw::c_int,
                base_curves: *mut root::vraudio::AudioBuffer,
                adder_curves: *mut root::vraudio::AudioBuffer,
            );
        }
        impl ReverbOnsetUpdateProcessor {
            #[inline]
            pub unsafe fn SetReverbTimes(&mut self, rt60_values: *const f32) {
                ReverbOnsetUpdateProcessor_SetReverbTimes(self, rt60_values)
            }
            #[inline]
            pub unsafe fn Process(
                &mut self,
                bandpassed_noise_left: *const [u64; 3usize],
                bandpassed_noise_right: *const [u64; 3usize],
                kernel_channel_left: *mut root::vraudio::AudioBuffer_Channel,
                kernel_channel_right: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool {
                ReverbOnsetUpdateProcessor_Process(
                    self,
                    bandpassed_noise_left,
                    bandpassed_noise_right,
                    kernel_channel_left,
                    kernel_channel_right,
                )
            }
            #[inline]
            pub unsafe fn new(
                frames_per_buffer: usize,
                sampling_rate: ::std::os::raw::c_int,
                base_curves: *mut root::vraudio::AudioBuffer,
                adder_curves: *mut root::vraudio::AudioBuffer,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ReverbOnsetUpdateProcessor_ReverbOnsetUpdateProcessor(
                    &mut __bindgen_tmp,
                    frames_per_buffer,
                    sampling_rate,
                    base_curves,
                    adder_curves,
                );
                __bindgen_tmp
            }
        }
        /// Implements a convolutional compensator for the spectral reverb onset curve.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct ReverbOnsetCompensator {
            /// Manager for all FFT related functionality (not owned).
            pub fft_manager_: *mut root::vraudio::FftManager,
            /// The system sampling rate.
            pub sampling_rate_: ::std::os::raw::c_int,
            /// The system number of frames per buffer.
            pub frames_per_buffer_: usize,
            /// Pre-generated band-passed noise to be used as a base for the reverb tail.
            pub bandpassed_noise_left_: [u64; 3usize],
            pub bandpassed_noise_right_: [u64; 3usize],
            /// The constituent curves used to generate the onset compensation envelopes.
            pub base_curves_: root::vraudio::AudioBuffer,
            pub adder_curves_: root::vraudio::AudioBuffer,
            /// Filter for processing the left reverberant channel.
            pub left_filter_: root::vraudio::PartitionedFftFilter,
            /// Filter for processing the right reverberant channel.
            pub right_filter_: root::vraudio::PartitionedFftFilter,
            /// Delay filter used to ensure the compensation curve starts at the same point
            /// /// as the spectral reverb.
            pub delay_filter_: root::vraudio::DelayFilter,
            /// Number of active update processors.
            pub num_active_processors_: usize,
            /// Active reverb update processors to replace the corresponding filter
            /// /// partitions of the reverb tail within each process call.
            pub update_processors_: [u64; 2usize],
            /// Temporary buffer used to process filter kernel partitions.
            pub temp_kernel_buffer_: root::vraudio::AudioBuffer,
            /// Temporary buffer to hold FFT frequency domain output.
            pub temp_freq_buffer_: root::vraudio::PartitionedFftFilter_FreqDomainBuffer,
        }
        #[test]
        fn bindgen_test_layout_ReverbOnsetCompensator() {
            assert_eq!(
                ::std::mem::size_of::<ReverbOnsetCompensator>(),
                1440usize,
                concat!("Size of: ", stringify!(ReverbOnsetCompensator))
            );
            assert_eq!(
                ::std::mem::align_of::<ReverbOnsetCompensator>(),
                8usize,
                concat!("Alignment of ", stringify!(ReverbOnsetCompensator))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).fft_manager_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(fft_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).sampling_rate_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(sampling_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).frames_per_buffer_
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).bandpassed_noise_left_
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(bandpassed_noise_left_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).bandpassed_noise_right_
                        as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(bandpassed_noise_right_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).base_curves_ as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(base_curves_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).adder_curves_ as *const _
                        as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(adder_curves_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).left_filter_ as *const _
                        as usize
                },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(left_filter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).right_filter_ as *const _
                        as usize
                },
                728usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(right_filter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).delay_filter_ as *const _
                        as usize
                },
                1240usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(delay_filter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).num_active_processors_
                        as *const _ as usize
                },
                1272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(num_active_processors_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).update_processors_
                        as *const _ as usize
                },
                1280usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(update_processors_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).temp_kernel_buffer_
                        as *const _ as usize
                },
                1296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(temp_kernel_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbOnsetCompensator>())).temp_freq_buffer_ as *const _
                        as usize
                },
                1368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbOnsetCompensator),
                    "::",
                    stringify!(temp_freq_buffer_)
                )
            );
        }
        extern "C" {
            /// Resets the reverb with a new set of reverberation times. The new tail is
            /// /// generated by replacing the current tail buffer by buffer.
            /// ///
            /// /// @param rt60_values |kNumReverbOctaveBands| values denoting the
            /// ///     reverberation decay time to -60dB in octave bands starting at
            /// ///     |kLowestOctaveBand|.
            /// /// @param gain Gain to be applied across all frequencies.
            #[link_name = "\u{1}?Update@ReverbOnsetCompensator@vraudio@@QEAAXPEBMM@Z"]
            pub fn ReverbOnsetCompensator_Update(
                this: *mut root::vraudio::ReverbOnsetCompensator,
                rt60_values: *const f32,
                gain: f32,
            );
        }
        extern "C" {
            /// Processes a mono |AudioBuffer| with a reverberant tail.
            /// ///
            /// /// @param input A mono |AudioBuffer| of input data.
            /// /// @param output Pointer to stereo output buffer.
            #[link_name = "\u{1}?Process@ReverbOnsetCompensator@vraudio@@QEAAXAEBVAudioBuffer@2@PEAV32@@Z"]
            pub fn ReverbOnsetCompensator_Process(
                this: *mut root::vraudio::ReverbOnsetCompensator,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            );
        }
        extern "C" {
            /// Constructs a |ReverbOnsetCompensator|.
            /// ///
            /// /// @param sampling_rate The sampling rate in Hz.
            /// /// @param frames_per_buffer The number of frames per buffer in the system.
            /// /// @param fft_manager Pointer to a FftManager to perform FFT transformations.
            #[link_name = "\u{1}??0ReverbOnsetCompensator@vraudio@@QEAA@H_KPEAVFftManager@1@@Z"]
            pub fn ReverbOnsetCompensator_ReverbOnsetCompensator(
                this: *mut root::vraudio::ReverbOnsetCompensator,
                sampling_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            );
        }
        impl ReverbOnsetCompensator {
            #[inline]
            pub unsafe fn Update(&mut self, rt60_values: *const f32, gain: f32) {
                ReverbOnsetCompensator_Update(self, rt60_values, gain)
            }
            #[inline]
            pub unsafe fn Process(
                &mut self,
                input: *const root::vraudio::AudioBuffer,
                output: *mut root::vraudio::AudioBuffer,
            ) {
                ReverbOnsetCompensator_Process(self, input, output)
            }
            #[inline]
            pub unsafe fn new(
                sampling_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
                fft_manager: *mut root::vraudio::FftManager,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ReverbOnsetCompensator_ReverbOnsetCompensator(
                    &mut __bindgen_tmp,
                    sampling_rate,
                    frames_per_buffer,
                    fft_manager,
                );
                __bindgen_tmp
            }
        }
        /// Class that implements a simple mono circular buffer, accepting input and
        /// output of different length.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct CircularBuffer {
            /// Number of input frames to be inserted into the buffer.
            pub num_input_frames_: usize,
            /// Number of output frames to be retrieved from the buffer.
            pub num_output_frames_: usize,
            /// Mono audio buffer to hold the data.
            pub buffer_: root::vraudio::AudioBuffer,
            /// Position at which we are writing into the buffer.
            pub write_cursor_: usize,
            /// position at which we are reading from the buffer.
            pub read_cursor_: usize,
            /// Number of frames of data currently stored within the buffer.
            pub num_valid_frames_: usize,
        }
        #[test]
        fn bindgen_test_layout_CircularBuffer() {
            assert_eq!(
                ::std::mem::size_of::<CircularBuffer>(),
                112usize,
                concat!("Size of: ", stringify!(CircularBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<CircularBuffer>(),
                8usize,
                concat!("Alignment of ", stringify!(CircularBuffer))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CircularBuffer>())).num_input_frames_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(num_input_frames_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CircularBuffer>())).num_output_frames_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(num_output_frames_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CircularBuffer>())).buffer_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CircularBuffer>())).write_cursor_ as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(write_cursor_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CircularBuffer>())).read_cursor_ as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(read_cursor_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CircularBuffer>())).num_valid_frames_ as *const _
                        as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CircularBuffer),
                    "::",
                    stringify!(num_valid_frames_)
                )
            );
        }
        extern "C" {
            /// Inserts a buffer of mono input into the |CircularBuffer| if space permits.
            /// ///
            /// /// @param input A channel of input data |num_input_frames| in length.
            /// /// @return True if there was space in the buffer and the input was
            /// ///     successfully inserted, false otherwise.
            #[link_name = "\u{1}?InsertBuffer@CircularBuffer@vraudio@@QEAA_NAEBVChannelView@2@@Z"]
            pub fn CircularBuffer_InsertBuffer(
                this: *mut root::vraudio::CircularBuffer,
                input: *const root::vraudio::AudioBuffer_Channel,
            ) -> bool;
        }
        extern "C" {
            /// Retrieves a buffer of output from the |CircularBuffer| if it contains
            /// /// sufficient data.
            /// ///
            /// /// @param output A channel to hold |num_output_frames| of output data. The
            /// ///     channel may be greater in length than |num_output_frames|, in this
            /// ///     case only the first |num_output_frames| will be overwritten.
            /// /// @return True if there was sufficient data in the buffer and the output was
            /// ///     successfully retrieved.
            #[link_name = "\u{1}?RetrieveBuffer@CircularBuffer@vraudio@@QEAA_NPEAVChannelView@2@@Z"]
            pub fn CircularBuffer_RetrieveBuffer(
                this: *mut root::vraudio::CircularBuffer,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool;
        }
        extern "C" {
            /// Retrieves a buffer of output from the |CircularBuffer| to an offset
            /// /// location in an output channel, provided it contains sufficient data.
            /// ///
            /// /// @param offset Number of samples of offset into the |output| channel.
            /// /// @param output A channel to hold |num_output_frames| of output data. The
            /// ///     channel may be greater in length than |num_output_frames| + |offset|,
            /// ///     in this case only the first |num_output_frames| after |offset| will be
            /// ///     overwritten.
            /// /// @return True if there was sufficient data in the buffer and the output was
            /// ///     successfully retrieved.
            #[link_name = "\u{1}?RetrieveBufferWithOffset@CircularBuffer@vraudio@@QEAA_N_KPEAVChannelView@2@@Z"]
            pub fn CircularBuffer_RetrieveBufferWithOffset(
                this: *mut root::vraudio::CircularBuffer,
                offset: usize,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool;
        }
        extern "C" {
            /// Resets the |CircularBuffer|.
            #[link_name = "\u{1}?Clear@CircularBuffer@vraudio@@QEAAXXZ"]
            pub fn CircularBuffer_Clear(this: *mut root::vraudio::CircularBuffer);
        }
        extern "C" {
            /// Constructs a circular buffer.
            /// ///
            /// /// @param buffer_length The length of the Circular buffer. This value must be
            /// ///     at least |num_input_frames| + |num_output_frames| so that we can always
            /// ///     either add or remove data.
            /// /// @param num_input_frames Length of the input buffers in frames.
            /// /// @param num_output_frames Length of the output buffers in frames.
            #[link_name = "\u{1}??0CircularBuffer@vraudio@@QEAA@_K00@Z"]
            pub fn CircularBuffer_CircularBuffer(
                this: *mut root::vraudio::CircularBuffer,
                buffer_length: usize,
                num_input_frames: usize,
                num_output_frames: usize,
            );
        }
        impl CircularBuffer {
            #[inline]
            pub unsafe fn InsertBuffer(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
            ) -> bool {
                CircularBuffer_InsertBuffer(self, input)
            }
            #[inline]
            pub unsafe fn RetrieveBuffer(
                &mut self,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool {
                CircularBuffer_RetrieveBuffer(self, output)
            }
            #[inline]
            pub unsafe fn RetrieveBufferWithOffset(
                &mut self,
                offset: usize,
                output: *mut root::vraudio::AudioBuffer_Channel,
            ) -> bool {
                CircularBuffer_RetrieveBufferWithOffset(self, offset, output)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                CircularBuffer_Clear(self)
            }
            #[inline]
            pub unsafe fn new(
                buffer_length: usize,
                num_input_frames: usize,
                num_output_frames: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                CircularBuffer_CircularBuffer(
                    &mut __bindgen_tmp,
                    buffer_length,
                    num_input_frames,
                    num_output_frames,
                );
                __bindgen_tmp
            }
        }
        /// Implements a spectral reverb producing a decorrelated stereo output. See:
        /// [1] E. Vickers, J-L Wu, P.G. Krishnan, R. N. K. Sadanandam, "Frequency Domain
        /// Artificial Reverberation using Spectral Magnitude Decay",
        /// https://goo.gl/hv1pdJ.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SpectralReverb {
            /// System sample rate.
            pub sample_rate_: ::std::os::raw::c_int,
            /// System frames per buffer.
            pub frames_per_buffer_: usize,
            /// Indices into the magnitude and overlap add delay lines, modulo of their
            /// /// respective lengths.
            pub magnitude_delay_index_: usize,
            pub overlap_add_index_: usize,
            /// Manages the time-frequency transforms and phase/magnitude-frequency
            /// /// transforms.
            pub fft_manager_: root::vraudio::FftManager,
            /// Buffer containing sines and cosines of random values between 0 and pi to be
            /// /// used for phase.
            pub sin_cos_random_phase_buffer_: root::vraudio::AudioBuffer,
            /// Buffer containing a triple overlapping hann window for windowing time
            /// /// domain data.
            pub unscaled_window_: root::vraudio::AudioBuffer,
            /// Buffer containing a triple overlapping hann window for windowing time
            /// /// domain data, this window has been scaled by the output gain factor.
            pub window_: root::vraudio::AudioBuffer,
            /// Buffer containing RT60 tuned feedback values.
            pub feedback_: root::vraudio::AudioBuffer,
            /// Buffer used to store scaling values which account for the different initial
            /// /// peak magnitudes for different RT60s.
            pub magnitude_compensation_: root::vraudio::AudioBuffer,
            /// Buffer that acts as the frequency domain magnitde delay.
            pub magnitude_delay_: root::vraudio::AudioBuffer,
            /// Buffer to contain a linear |kFftSize| chunk of input data.
            pub fft_size_input_: root::vraudio::AudioBuffer,
            /// Circular buffers to sit at the input and output of the |Process()| method
            /// /// to allow |frames_per_buffer_| to differ from |kFftSize|.
            pub input_circular_buffer_: root::vraudio::CircularBuffer,
            pub output_circular_buffers_: [u64; 3usize],
            /// Time domain buffer used to store reverb before the overlap add operation.
            pub out_time_buffer_: root::vraudio::AudioBuffer,
            /// Temporary frequency domain buffer, used to store frequency domain data when
            /// /// transforming between Pffft and Canonical format frequency domain data.
            pub temp_freq_buffer_: root::vraudio::AudioBuffer,
            /// Buffer used to store feedback scaled magnitude values.
            pub scaled_magnitude_buffer_: root::vraudio::AudioBuffer,
            /// Buffer used for the accumulation of scaled magnitude buffers.
            pub temp_magnitude_buffer_: root::vraudio::AudioBuffer,
            /// Buffer used to store randomized phase.
            pub temp_phase_buffer_: root::vraudio::AudioBuffer,
            /// Buffers used to calculate the overlap add at the output.
            pub output_accumulator_: [u64; 3usize],
            /// Processing of the spectral reverb is bypassed when the feedback values are
            /// /// all approximately zero OR when the gain is set to near zero.
            pub is_gain_near_zero_: bool,
            pub is_feedback_near_zero_: bool,
        }
        #[test]
        fn bindgen_test_layout_SpectralReverb() {
            assert_eq!(
                ::std::mem::size_of::<SpectralReverb>(),
                1248usize,
                concat!("Size of: ", stringify!(SpectralReverb))
            );
            assert_eq!(
                ::std::mem::align_of::<SpectralReverb>(),
                8usize,
                concat!("Alignment of ", stringify!(SpectralReverb))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).sample_rate_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(sample_rate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).frames_per_buffer_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(frames_per_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).magnitude_delay_index_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(magnitude_delay_index_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).overlap_add_index_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(overlap_add_index_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).fft_manager_ as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(fft_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).sin_cos_random_phase_buffer_
                        as *const _ as usize
                },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(sin_cos_random_phase_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).unscaled_window_ as *const _ as usize
                },
                288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(unscaled_window_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SpectralReverb>())).window_ as *const _ as usize },
                360usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(window_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).feedback_ as *const _ as usize
                },
                432usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(feedback_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).magnitude_compensation_ as *const _
                        as usize
                },
                504usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(magnitude_compensation_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).magnitude_delay_ as *const _ as usize
                },
                576usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(magnitude_delay_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).fft_size_input_ as *const _ as usize
                },
                648usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(fft_size_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).input_circular_buffer_ as *const _
                        as usize
                },
                720usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(input_circular_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).output_circular_buffers_ as *const _
                        as usize
                },
                832usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(output_circular_buffers_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).out_time_buffer_ as *const _ as usize
                },
                856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(out_time_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).temp_freq_buffer_ as *const _
                        as usize
                },
                928usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(temp_freq_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).scaled_magnitude_buffer_ as *const _
                        as usize
                },
                1000usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(scaled_magnitude_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).temp_magnitude_buffer_ as *const _
                        as usize
                },
                1072usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(temp_magnitude_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).temp_phase_buffer_ as *const _
                        as usize
                },
                1144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(temp_phase_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).output_accumulator_ as *const _
                        as usize
                },
                1216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(output_accumulator_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).is_gain_near_zero_ as *const _
                        as usize
                },
                1240usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(is_gain_near_zero_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SpectralReverb>())).is_feedback_near_zero_ as *const _
                        as usize
                },
                1241usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SpectralReverb),
                    "::",
                    stringify!(is_feedback_near_zero_)
                )
            );
        }
        extern "C" {
            /// Sets the overall gain to be applied to the output of the reverb.
            /// ///
            /// /// @param gain Gain to be applied to the reverb output, min value 0.0f.
            #[link_name = "\u{1}?SetGain@SpectralReverb@vraudio@@QEAAXM@Z"]
            pub fn SpectralReverb_SetGain(this: *mut root::vraudio::SpectralReverb, gain: f32);
        }
        extern "C" {
            /// Sets the |SpectralReverb|'s reverberation times in different frequency
            /// /// bands. Supports times between:
            /// /// (0.15 * 48000 / |sample_rate|)s and (25 * 48000 / |sample_rate|)s.
            /// ///
            /// /// @param rt60_values |kNumReverbOctaveBands| values denoting the
            /// ///     reverberation decay time to -60dB in octave bands starting at
            /// ///     |kLowestOctaveBand|.
            #[link_name = "\u{1}?SetRt60PerOctaveBand@SpectralReverb@vraudio@@QEAAXPEBM@Z"]
            pub fn SpectralReverb_SetRt60PerOctaveBand(
                this: *mut root::vraudio::SpectralReverb,
                rt60_values: *const f32,
            );
        }
        extern "C" {
            /// Applies reverb to an input channel of audio data and produces a stereo
            /// /// output.
            /// ///
            /// /// @param input Mono inpu data.
            /// /// @param left_out Left channel of reverberated output.
            /// /// @param right_out Right channel of reverberated output.
            #[link_name = "\u{1}?Process@SpectralReverb@vraudio@@QEAAXAEBVChannelView@2@PEAV32@1@Z"]
            pub fn SpectralReverb_Process(
                this: *mut root::vraudio::SpectralReverb,
                input: *const root::vraudio::AudioBuffer_Channel,
                left_out: *mut root::vraudio::AudioBuffer_Channel,
                right_out: *mut root::vraudio::AudioBuffer_Channel,
            );
        }
        extern "C" {
            /// Constructs a spectral reverb.
            /// ///
            /// /// @param sample_rate The system sample rate.
            /// /// @param frames_per_buffer System frames per buffer of input and output.
            /// ///     Note that this class expects power of two buffers of input and output.
            #[link_name = "\u{1}??0SpectralReverb@vraudio@@QEAA@H_K@Z"]
            pub fn SpectralReverb_SpectralReverb(
                this: *mut root::vraudio::SpectralReverb,
                sample_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
            );
        }
        impl SpectralReverb {
            #[inline]
            pub unsafe fn SetGain(&mut self, gain: f32) {
                SpectralReverb_SetGain(self, gain)
            }
            #[inline]
            pub unsafe fn SetRt60PerOctaveBand(&mut self, rt60_values: *const f32) {
                SpectralReverb_SetRt60PerOctaveBand(self, rt60_values)
            }
            #[inline]
            pub unsafe fn Process(
                &mut self,
                input: *const root::vraudio::AudioBuffer_Channel,
                left_out: *mut root::vraudio::AudioBuffer_Channel,
                right_out: *mut root::vraudio::AudioBuffer_Channel,
            ) {
                SpectralReverb_Process(self, input, left_out, right_out)
            }
            #[inline]
            pub unsafe fn new(
                sample_rate: ::std::os::raw::c_int,
                frames_per_buffer: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SpectralReverb_SpectralReverb(&mut __bindgen_tmp, sample_rate, frames_per_buffer);
                __bindgen_tmp
            }
        }
        /// Implements a spectral reverb producing a decorrelated stereo output with
        /// onset compensated by a pair of convolution filters.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReverbNode {
            pub _base: root::vraudio::ProcessingNode,
            /// Global system configuration.
            pub system_settings_: *const root::vraudio::SystemSettings,
            /// Current reverb properties.
            pub reverb_properties_: root::vraudio::ReverbProperties,
            /// New reverb properties.
            pub new_reverb_properties_: root::vraudio::ReverbProperties,
            /// Per band reverb time update step sizes.
            pub rt60_band_update_steps_: [u64; 3usize],
            /// Update step size for the gain parameter.
            pub gain_update_step_: f32,
            /// Denotes whether the rt60s are currently being updated.
            pub rt60_updating_: bool,
            /// Denotes whether the gain is currently being updated.
            pub gain_updating_: bool,
            /// Number of buffers to updae rt60s over.
            pub buffers_to_update_: f32,
            /// DSP class to perform filtering associated with the reverb.
            pub spectral_reverb_: root::vraudio::SpectralReverb,
            /// DSP class to perform spectral reverb onset compensation.
            pub onset_compensator_: root::vraudio::ReverbOnsetCompensator,
            /// Number of frames of zeroed out data to be processed by the node to ensure
            /// /// the entire tail is rendered after input has ceased.
            pub num_frames_processed_on_empty_input_: usize,
            /// Longest current reverb time, across all bands, in frames.
            pub reverb_length_frames_: usize,
            /// Output buffers for mixing spectral reverb and compensator output.
            pub output_buffer_: root::vraudio::AudioBuffer,
            pub compensator_output_buffer_: root::vraudio::AudioBuffer,
            /// Silence mono buffer to render reverb tails during the absence of input
            /// /// buffers.
            pub silence_mono_buffer_: root::vraudio::AudioBuffer,
        }
        #[test]
        fn bindgen_test_layout_ReverbNode() {
            assert_eq!(
                ::std::mem::size_of::<ReverbNode>(),
                3232usize,
                concat!("Size of: ", stringify!(ReverbNode))
            );
            assert_eq!(
                ::std::mem::align_of::<ReverbNode>(),
                8usize,
                concat!("Alignment of ", stringify!(ReverbNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).system_settings_ as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).reverb_properties_ as *const _ as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(reverb_properties_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).new_reverb_properties_ as *const _
                        as usize
                },
                232usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(new_reverb_properties_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).rt60_band_update_steps_ as *const _
                        as usize
                },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(rt60_band_update_steps_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).gain_update_step_ as *const _ as usize
                },
                296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(gain_update_step_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).rt60_updating_ as *const _ as usize
                },
                300usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(rt60_updating_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).gain_updating_ as *const _ as usize
                },
                301usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(gain_updating_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).buffers_to_update_ as *const _ as usize
                },
                304usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(buffers_to_update_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).spectral_reverb_ as *const _ as usize
                },
                312usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(spectral_reverb_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).onset_compensator_ as *const _ as usize
                },
                1560usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(onset_compensator_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).num_frames_processed_on_empty_input_
                        as *const _ as usize
                },
                3000usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(num_frames_processed_on_empty_input_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).reverb_length_frames_ as *const _
                        as usize
                },
                3008usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(reverb_length_frames_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).output_buffer_ as *const _ as usize
                },
                3016usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(output_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).compensator_output_buffer_ as *const _
                        as usize
                },
                3088usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(compensator_output_buffer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReverbNode>())).silence_mono_buffer_ as *const _ as usize
                },
                3160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReverbNode),
                    "::",
                    stringify!(silence_mono_buffer_)
                )
            );
        }
        extern "C" {
            /// Updates the |SpectralReverb| using the current room properties or RT60
            /// /// values depending on the system settings.
            #[link_name = "\u{1}?Update@ReverbNode@vraudio@@QEAAXXZ"]
            pub fn ReverbNode_Update(this: *mut root::vraudio::ReverbNode);
        }
        extern "C" {
            /// Constructs a |ReverbNode|.
            /// ///
            /// /// @param system_settings Global system configuration.
            /// /// @param fft_manager Pointer to a manager to perform FFT transformations.
            #[link_name = "\u{1}??0ReverbNode@vraudio@@QEAA@AEBVSystemSettings@1@PEAVFftManager@1@@Z"]
            pub fn ReverbNode_ReverbNode(
                this: *mut root::vraudio::ReverbNode,
                system_settings: *const root::vraudio::SystemSettings,
                fft_manager: *mut root::vraudio::FftManager,
            );
        }
        impl ReverbNode {
            #[inline]
            pub unsafe fn Update(&mut self) {
                ReverbNode_Update(self)
            }
            #[inline]
            pub unsafe fn new(
                system_settings: *const root::vraudio::SystemSettings,
                fft_manager: *mut root::vraudio::FftManager,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ReverbNode_ReverbNode(&mut __bindgen_tmp, system_settings, fft_manager);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@ReverbNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn ReverbNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Node that accepts single mono sound object buffer as input and pans into a
        /// stereo panorama.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq)]
        pub struct StereoMixingPannerNode {
            pub _base: root::vraudio::ProcessingNode,
            pub system_settings_: *const root::vraudio::SystemSettings,
            /// |GainMixer| instance.
            pub gain_mixer_: root::vraudio::GainMixer,
            /// Panning coefficients to be applied the input.
            pub coefficients_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_StereoMixingPannerNode() {
            assert_eq!(
                ::std::mem::size_of::<StereoMixingPannerNode>(),
                368usize,
                concat!("Size of: ", stringify!(StereoMixingPannerNode))
            );
            assert_eq!(
                ::std::mem::align_of::<StereoMixingPannerNode>(),
                8usize,
                concat!("Alignment of ", stringify!(StereoMixingPannerNode))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StereoMixingPannerNode>())).system_settings_ as *const _
                        as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StereoMixingPannerNode),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StereoMixingPannerNode>())).gain_mixer_ as *const _
                        as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StereoMixingPannerNode),
                    "::",
                    stringify!(gain_mixer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StereoMixingPannerNode>())).coefficients_ as *const _
                        as usize
                },
                344usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StereoMixingPannerNode),
                    "::",
                    stringify!(coefficients_)
                )
            );
        }
        extern "C" {
            /// Initializes StereoMixingPannerNode class.
            /// ///
            /// /// @param system_settings Global system configuration.
            #[link_name = "\u{1}??0StereoMixingPannerNode@vraudio@@QEAA@AEBVSystemSettings@1@@Z"]
            pub fn StereoMixingPannerNode_StereoMixingPannerNode(
                this: *mut root::vraudio::StereoMixingPannerNode,
                system_settings: *const root::vraudio::SystemSettings,
            );
        }
        impl StereoMixingPannerNode {
            #[inline]
            pub unsafe fn new(system_settings: *const root::vraudio::SystemSettings) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                StereoMixingPannerNode_StereoMixingPannerNode(&mut __bindgen_tmp, system_settings);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// Implements ProcessingNode.
            #[link_name = "\u{1}?AudioProcess@StereoMixingPannerNode@vraudio@@MEAAPEBVAudioBuffer@2@AEBVNodeInput@ProcessingNode@2@@Z"]
            pub fn StereoMixingPannerNode_AudioProcess(
                this: *mut ::std::os::raw::c_void,
                input: *const root::vraudio::ProcessingNode_NodeInput,
            ) -> *const root::vraudio::AudioBuffer;
        }
        /// Audio sink node that reads from multiple inputs.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct SinkNode {
            pub _base: root::vraudio::Node,
            pub _base_1: root::vraudio::SubscriberNode,
            /// Input stream to poll for incoming data.
            pub input_stream_: root::vraudio::Node_Input,
        }
        pub type SinkNode_PublisherNodeType = root::vraudio::PublisherNode;
        #[test]
        fn bindgen_test_layout_SinkNode() {
            assert_eq!(
                ::std::mem::size_of::<SinkNode>(),
                120usize,
                concat!("Size of: ", stringify!(SinkNode))
            );
            assert_eq!(
                ::std::mem::align_of::<SinkNode>(),
                8usize,
                concat!("Alignment of ", stringify!(SinkNode))
            );
        }
        extern "C" {
            /// Polls for data on all inputs of the sink node.
            /// ///
            /// /// @return A vector of input data.
            #[link_name = "\u{1}?ReadInputs@SinkNode@vraudio@@QEAAAEBV?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@XZ"]
            pub fn SinkNode_ReadInputs(this: *mut root::vraudio::SinkNode) -> *const [u64; 3usize];
        }
        extern "C" {
            #[link_name = "\u{1}??0SinkNode@vraudio@@QEAA@XZ"]
            pub fn SinkNode_SinkNode(this: *mut root::vraudio::SinkNode);
        }
        impl SinkNode {
            #[inline]
            pub unsafe fn ReadInputs(&mut self) -> *const [u64; 3usize] {
                SinkNode_ReadInputs(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SinkNode_SinkNode(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            /// SubscriberNode<AudioBuffer> implementation.
            #[link_name = "\u{1}?Connect@SinkNode@vraudio@@UEAAXAEBV?$shared_ptr@V?$PublisherNode@PEBVAudioBuffer@vraudio@@@vraudio@@@std@@@Z"]
            pub fn SinkNode_Connect(this: *mut ::std::os::raw::c_void, publisher_node: *const u8);
        }
        extern "C" {
            /// Node implementation.
            #[link_name = "\u{1}?Process@SinkNode@vraudio@@UEAAXXZ"]
            pub fn SinkNode_Process(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?CleanUp@SinkNode@vraudio@@UEAA_NXZ"]
            pub fn SinkNode_CleanUp(this: *mut ::std::os::raw::c_void) -> bool;
        }
        /// The GraphManager class manages the construction and lifetime of the audio
        /// processing graph. It owns the output node that connects the audio processing
        /// graph to the audio hardware.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct GraphManager {
            /// Flag indicating if room effects are enabled.
            pub room_effects_enabled_: bool,
            /// Mono mixer to accumulate all reverb sources.
            pub reverb_gain_mixer_node_: [u64; 2usize],
            /// Reflections node.
            pub reflections_node_: [u64; 2usize],
            /// Mono mixer node to accumulate the early reflection sources.
            pub reflections_gain_mixer_node_: [u64; 2usize],
            /// Reverb node.
            pub reverb_node_: [u64; 2usize],
            /// Ambisonic output mixer to accumulate incoming ambisonic inputs into a
            /// /// single ambisonic output buffer.
            pub ambisonic_output_mixer_: u64,
            /// Global config passed in during construction.
            pub config_: root::vraudio::GraphManagerConfig,
            /// Manages system wide settings.
            pub system_settings_: *const root::vraudio::SystemSettings,
            /// Provides Ambisonic encoding coefficients.
            pub lookup_table_: u64,
            /// |FftManager| to be used in nodes that require FFT transformations.
            pub fft_manager_: root::vraudio::FftManager,
            /// |Resampler| to be used to convert HRIRs to the system sample rate.
            pub resampler_: root::vraudio::Resampler,
            /// Ambisonic mixer nodes per each ambisonic order to accumulate the
            /// /// ambisonic sources for the corresponding binaural Ambisonic decoders.
            pub ambisonic_mixer_nodes_: [u64; 8usize],
            /// Stereo mixer to combine all the stereo and binaural output.
            pub stereo_mixer_node_: [u64; 2usize],
            /// Ambisonic mixing encoder node to apply encoding coefficients and accumulate
            /// /// the Ambisonic buffers.
            pub ambisonic_mixing_encoder_nodes_: [u64; 8usize],
            /// Stereo mixing panner node to apply stereo panning gains and accumulate the
            /// /// buffers.
            pub stereo_mixing_panner_node_: [u64; 2usize],
            /// Output node that enables audio playback of a single audio stream.
            pub output_node_: [u64; 2usize],
            /// Holds all registered source nodes (independently of their type) and
            /// /// allows look up by id.
            pub source_nodes_: [u64; 8usize],
        }
        #[test]
        fn bindgen_test_layout_GraphManager() {
            assert_eq!(
                ::std::mem::size_of::<GraphManager>(),
                848usize,
                concat!("Size of: ", stringify!(GraphManager))
            );
            assert_eq!(
                ::std::mem::align_of::<GraphManager>(),
                8usize,
                concat!("Alignment of ", stringify!(GraphManager))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).room_effects_enabled_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(room_effects_enabled_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).reverb_gain_mixer_node_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(reverb_gain_mixer_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).reflections_node_ as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(reflections_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).reflections_gain_mixer_node_
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(reflections_gain_mixer_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).reverb_node_ as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(reverb_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).ambisonic_output_mixer_ as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(ambisonic_output_mixer_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GraphManager>())).config_ as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(config_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).system_settings_ as *const _ as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).lookup_table_ as *const _ as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(lookup_table_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).fft_manager_ as *const _ as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(fft_manager_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GraphManager>())).resampler_ as *const _ as usize },
                344usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(resampler_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).ambisonic_mixer_nodes_ as *const _
                        as usize
                },
                608usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(ambisonic_mixer_nodes_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).stereo_mixer_node_ as *const _ as usize
                },
                672usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(stereo_mixer_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).ambisonic_mixing_encoder_nodes_
                        as *const _ as usize
                },
                688usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(ambisonic_mixing_encoder_nodes_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).stereo_mixing_panner_node_ as *const _
                        as usize
                },
                752usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(stereo_mixing_panner_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).output_node_ as *const _ as usize
                },
                768usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(output_node_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GraphManager>())).source_nodes_ as *const _ as usize
                },
                784usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GraphManager),
                    "::",
                    stringify!(source_nodes_)
                )
            );
        }
        extern "C" {
            /// Returns the sink node the audio graph is connected to.
            /// ///
            /// /// @return Shared pointer of the sink node.
            #[link_name = "\u{1}?GetSinkNode@GraphManager@vraudio@@QEAA?AV?$shared_ptr@VSinkNode@vraudio@@@std@@XZ"]
            pub fn GraphManager_GetSinkNode(
                this: *mut root::vraudio::GraphManager,
            ) -> [u64; 2usize];
        }
        extern "C" {
            /// Triggers processing of the audio graph for all the connected nodes.
            #[link_name = "\u{1}?Process@GraphManager@vraudio@@QEAAXXZ"]
            pub fn GraphManager_Process(this: *mut root::vraudio::GraphManager);
        }
        extern "C" {
            /// Returns a mutable pointer to the |AudioBuffer| of an audio source with
            /// /// given |source_id|. Calls to this method must be synchronized with the audio
            /// /// graph processing.
            /// ///
            /// /// @param source_id Source id.
            /// /// @return Mutable audio buffer pointer. Nullptr if source_id not found.
            #[link_name = "\u{1}?GetMutableAudioBuffer@GraphManager@vraudio@@QEAAPEAVAudioBuffer@2@H@Z"]
            pub fn GraphManager_GetMutableAudioBuffer(
                this: *mut root::vraudio::GraphManager,
                source_id: root::vraudio::SourceId,
            ) -> *mut root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Creates an ambisonic panner source with given |sound_object_source_id|.
            /// ///
            /// /// Processing graph:
            /// ///
            /// ///                          +-------------------+
            /// ///                          |                   |
            /// ///             +------------+ SoundObjectSource +----------+
            /// ///             |            |                   |          |
            /// ///             |            +---------+---------+          |
            /// ///             |                                           |
            /// /// +-----------v-----------+                     +---------v----------+
            /// /// |                       |                     |                    |
            /// /// | AmbisonicMixingPanner |                     | StereoMixingPanner |
            /// /// |                       |                     |                    |
            /// /// +-----------+-----------+                     +---------+----------+
            /// ///             |                                           |
            /// /// +-----------v-----------+                     +---------v----------+
            /// /// |                       |                     |                    |
            /// /// |    AmbisonicMixer     |                     |    StereoMixer     |
            /// /// |                       |                     |                    |
            /// /// +-----------+-----------+                     +--------------------+
            /// ///
            /// ///
            /// /// @param sound_object_source_id Id of sound object source.
            /// /// @param enable_hrtf Flag to enable HRTF-based spatialization.
            #[link_name = "\u{1}?CreateAmbisonicPannerSource@GraphManager@vraudio@@QEAAXH_N@Z"]
            pub fn GraphManager_CreateAmbisonicPannerSource(
                this: *mut root::vraudio::GraphManager,
                sound_object_source_id: root::vraudio::SourceId,
                enable_hrtf: bool,
            );
        }
        extern "C" {
            /// Creates a new stereo non-spatialized source with given |stereo_source_id|.
            /// ///
            /// /// Processing graph:
            /// ///
            /// ///                            +--------------+
            /// ///                            |              |
            /// ///                            | StereoSource |
            /// ///                            |              |
            /// ///                            +-------+------+
            /// ///                                    |
            /// ///                            +-------v------+
            /// ///                            |              |
            /// ///                            |     Gain     |
            /// ///                            |              |
            /// ///                            +-------+------+
            /// ///                                    |
            /// ///                            +-------V------+
            /// ///                            |              |
            /// ///                            | StereoMixer  |
            /// ///                            |              |
            /// ///                            +--------------+
            /// ///
            /// /// @param stereo_source_id Id of new stereo source.
            #[link_name = "\u{1}?CreateStereoSource@GraphManager@vraudio@@QEAAXH@Z"]
            pub fn GraphManager_CreateStereoSource(
                this: *mut root::vraudio::GraphManager,
                stereo_source_id: root::vraudio::SourceId,
            );
        }
        extern "C" {
            /// Destroys source with given |source_id|. Note that this call only sets a
            /// /// flag to indicate that this source can be removed. The actual disconnect
            /// /// happens from the audio processing thread the next time the processing graph
            /// /// is triggered.
            /// ///
            /// /// @param source_id Id of source to be destroyed.
            #[link_name = "\u{1}?DestroySource@GraphManager@vraudio@@QEAAXH@Z"]
            pub fn GraphManager_DestroySource(
                this: *mut root::vraudio::GraphManager,
                source_id: root::vraudio::SourceId,
            );
        }
        extern "C" {
            /// Creates a new ambisonic source subgraph with given |ambisonic_source_id|.
            /// /// Note: Ambisonic source subgraph is only created if the rendering mode is
            /// /// HRTF.
            /// ///
            /// /// Processing graph (all the graphs created using http://asciiflow.com/):
            /// ///
            /// ///                           +-----------------+
            /// ///                           |                 |
            /// ///                   +-------+ AmbisonicSource +-------+
            /// ///                   |       |                 |       |
            /// ///                   |       +-----------------+       |
            /// ///                   |                                 |
            /// ///              +----v---+                  +----------v---------+
            /// ///              |        |                  |                    |
            /// ///              |  Gain  |               +--+ MonoFromSoundfield +--+
            /// ///              |        |               |  |                    |  |
            /// ///              +----+---+               |  +--------------------+  |
            /// ///                   |                   |                          |
            /// ///                   |                   |                          |
            /// ///          +--------v-------+  +--------v---------+         +------v------+
            /// ///          |                |  |                  |         |             |
            /// ///          | Foa/HoaRotator |  | ReflectionsMixer |         | ReverbMixer |
            /// ///          |                |  |                  |         |             |
            /// ///          +--------+-------+  +--------+---------+         +------+------+
            /// ///                   |
            /// ///          +--------v-------+
            /// ///          |                |
            /// ///          | AmbisonicMixer |
            /// ///          |                |
            /// ///          +--------+-------+
            /// ///
            /// /// @param ambisonic_source_id Id of new ambisonic source.
            /// /// @param num_channels Number of input channels of ambisonic source node.
            #[link_name = "\u{1}?CreateAmbisonicSource@GraphManager@vraudio@@QEAAXH_K@Z"]
            pub fn GraphManager_CreateAmbisonicSource(
                this: *mut root::vraudio::GraphManager,
                ambisonic_source_id: root::vraudio::SourceId,
                num_channels: usize,
            );
        }
        extern "C" {
            /// Creates a new sound object source with given |sound_object_source_id|.
            /// ///
            /// /// Processing graph:
            /// ///
            /// ///                          +-------------------+
            /// ///                          |                   |
            /// ///            +-------------+ SoundObjectSource +----------+
            /// ///            |             |                   |          |
            /// ///            |             +---------+---------+          |
            /// ///            |                       |                    |
            /// /// +----------v-----------+ +---------v---------+ +--------v--------+
            /// /// |                      | |                   | |                 |
            /// /// | ReflectionsGainMixer | | DirectAttenuation | | ReverbGainMixer |
            /// /// |                      | |                   | |                 |
            /// /// +----------+-----------+ +---------+---------+ +--------+--------+
            /// ///                                    |
            /// ///                          +---------v---------+
            /// ///                  HRTF    |                   |    Stereo Panning
            /// ///             +------------+     Occlusion     +----------+
            /// ///             |            |                   |          |
            /// ///             |            +---------+---------+          |
            /// ///             |                      |                    |
            /// /// +-----------v-----------+ +--------v--------+ +---------v----------+
            /// /// |                       | |                 | |                    |
            /// /// | AmbisonicMixingPanner | | NearFieldEffect | | StereoMixingPanner |
            /// /// |                       | |                 | |                    |
            /// /// +-----------+-----------+ +--------+--------+ +---------+----------+
            /// ///             |                      |                    |
            /// /// +-----------v-----------+ +--------v--------+           |
            /// /// |                       | |                 |           |
            /// /// |    AmbisonicMixer     | |   StereoMixer   <-----------+
            /// /// |                       | |                 |
            /// /// +-----------+-----------+ +-----------------+
            /// ///
            /// ///
            /// /// @param sound_object_source_id Id of sound object source.
            /// /// @param ambisonic_order Ambisonic order to encode the sound object source.
            /// /// @param enable_hrtf Flag to enable HRTF-based rendering.
            /// /// @param enable_direct_rendering Flag to enable direct source rendering.
            #[link_name = "\u{1}?CreateSoundObjectSource@GraphManager@vraudio@@QEAAXHH_N0@Z"]
            pub fn GraphManager_CreateSoundObjectSource(
                this: *mut root::vraudio::GraphManager,
                sound_object_source_id: root::vraudio::SourceId,
                ambisonic_order: ::std::os::raw::c_int,
                enable_hrtf: bool,
                enable_direct_rendering: bool,
            );
        }
        extern "C" {
            /// Mutes on/off the room effects mixers.
            /// ///
            /// /// @param Whether to enable room effects.
            #[link_name = "\u{1}?EnableRoomEffects@GraphManager@vraudio@@QEAAX_N@Z"]
            pub fn GraphManager_EnableRoomEffects(
                this: *mut root::vraudio::GraphManager,
                enable: bool,
            );
        }
        extern "C" {
            /// Returns the last processed output audio buffer of the ambisonic mix with
            /// /// the highest possible ambisonic channel configuration. Note that, this
            /// /// method will *not* trigger the processing of the audio graph.
            /// /// |GraphManager::Process| must be called prior to this method call to ensure
            /// /// that the output buffer is up-to-date.
            /// ///
            /// /// @return Output audio buffer of the ambisonic mix, or nullptr if no output.
            #[link_name = "\u{1}?GetAmbisonicBuffer@GraphManager@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn GraphManager_GetAmbisonicBuffer(
                this: *const root::vraudio::GraphManager,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Returns the last processed output audio buffer of the stereo (binaural)
            /// /// mix. Note that, this method will *not* trigger the processing of the audio
            /// /// graph. |GraphManager::Process| must be called prior to this method call to
            /// /// ensure that the output buffer is up-to-date.
            /// ///
            /// /// @return Output audio buffer of the stereo mix, or nullptr if no output.
            #[link_name = "\u{1}?GetStereoBuffer@GraphManager@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn GraphManager_GetStereoBuffer(
                this: *const root::vraudio::GraphManager,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Returns the maximum allowed number of ambisonic channels.
            /// ///
            /// /// @return Number of channels based on Ambisonic order in the global config.
            #[link_name = "\u{1}?GetNumMaxAmbisonicChannels@GraphManager@vraudio@@QEBA_KXZ"]
            pub fn GraphManager_GetNumMaxAmbisonicChannels(
                this: *const root::vraudio::GraphManager,
            ) -> usize;
        }
        extern "C" {
            /// Returns whether the room effects graph is enabled.
            /// ///
            /// /// @return True if room effects are enabled.
            #[link_name = "\u{1}?GetRoomEffectsEnabled@GraphManager@vraudio@@QEBA_NXZ"]
            pub fn GraphManager_GetRoomEffectsEnabled(
                this: *const root::vraudio::GraphManager,
            ) -> bool;
        }
        extern "C" {
            /// Updates the room reflections with the current properties for room effects
            /// /// processing.
            #[link_name = "\u{1}?UpdateRoomReflections@GraphManager@vraudio@@QEAAXXZ"]
            pub fn GraphManager_UpdateRoomReflections(this: *mut root::vraudio::GraphManager);
        }
        extern "C" {
            /// Updates the room reverb.
            #[link_name = "\u{1}?UpdateRoomReverb@GraphManager@vraudio@@QEAAXXZ"]
            pub fn GraphManager_UpdateRoomReverb(this: *mut root::vraudio::GraphManager);
        }
        extern "C" {
            /// Initializes GraphManager class.
            /// ///
            /// /// @param system_settings Global system configuration.
            #[link_name = "\u{1}??0GraphManager@vraudio@@QEAA@AEBVSystemSettings@1@@Z"]
            pub fn GraphManager_GraphManager(
                this: *mut root::vraudio::GraphManager,
                system_settings: *const root::vraudio::SystemSettings,
            );
        }
        impl GraphManager {
            #[inline]
            pub unsafe fn GetSinkNode(&mut self) -> [u64; 2usize] {
                GraphManager_GetSinkNode(self)
            }
            #[inline]
            pub unsafe fn Process(&mut self) {
                GraphManager_Process(self)
            }
            #[inline]
            pub unsafe fn GetMutableAudioBuffer(
                &mut self,
                source_id: root::vraudio::SourceId,
            ) -> *mut root::vraudio::AudioBuffer {
                GraphManager_GetMutableAudioBuffer(self, source_id)
            }
            #[inline]
            pub unsafe fn CreateAmbisonicPannerSource(
                &mut self,
                sound_object_source_id: root::vraudio::SourceId,
                enable_hrtf: bool,
            ) {
                GraphManager_CreateAmbisonicPannerSource(self, sound_object_source_id, enable_hrtf)
            }
            #[inline]
            pub unsafe fn CreateStereoSource(&mut self, stereo_source_id: root::vraudio::SourceId) {
                GraphManager_CreateStereoSource(self, stereo_source_id)
            }
            #[inline]
            pub unsafe fn DestroySource(&mut self, source_id: root::vraudio::SourceId) {
                GraphManager_DestroySource(self, source_id)
            }
            #[inline]
            pub unsafe fn CreateAmbisonicSource(
                &mut self,
                ambisonic_source_id: root::vraudio::SourceId,
                num_channels: usize,
            ) {
                GraphManager_CreateAmbisonicSource(self, ambisonic_source_id, num_channels)
            }
            #[inline]
            pub unsafe fn CreateSoundObjectSource(
                &mut self,
                sound_object_source_id: root::vraudio::SourceId,
                ambisonic_order: ::std::os::raw::c_int,
                enable_hrtf: bool,
                enable_direct_rendering: bool,
            ) {
                GraphManager_CreateSoundObjectSource(
                    self,
                    sound_object_source_id,
                    ambisonic_order,
                    enable_hrtf,
                    enable_direct_rendering,
                )
            }
            #[inline]
            pub unsafe fn EnableRoomEffects(&mut self, enable: bool) {
                GraphManager_EnableRoomEffects(self, enable)
            }
            #[inline]
            pub unsafe fn GetAmbisonicBuffer(&self) -> *const root::vraudio::AudioBuffer {
                GraphManager_GetAmbisonicBuffer(self)
            }
            #[inline]
            pub unsafe fn GetStereoBuffer(&self) -> *const root::vraudio::AudioBuffer {
                GraphManager_GetStereoBuffer(self)
            }
            #[inline]
            pub unsafe fn GetNumMaxAmbisonicChannels(&self) -> usize {
                GraphManager_GetNumMaxAmbisonicChannels(self)
            }
            #[inline]
            pub unsafe fn GetRoomEffectsEnabled(&self) -> bool {
                GraphManager_GetRoomEffectsEnabled(self)
            }
            #[inline]
            pub unsafe fn UpdateRoomReflections(&mut self) {
                GraphManager_UpdateRoomReflections(self)
            }
            #[inline]
            pub unsafe fn UpdateRoomReverb(&mut self) {
                GraphManager_UpdateRoomReverb(self)
            }
            #[inline]
            pub unsafe fn new(system_settings: *const root::vraudio::SystemSettings) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                GraphManager_GraphManager(&mut __bindgen_tmp, system_settings);
                __bindgen_tmp
            }
        }
        /// Lock-less task queue which is thread safe for cocurrent task producers and a
        /// single task executor thread.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct LocklessTaskQueue {
            /// Pointer to head node of free list.
            pub free_list_head_: u64,
            /// Pointer to head node of task list.
            pub task_list_head_: u64,
            /// Holds preallocated nodes.
            pub nodes_: [u64; 3usize],
            /// Temporary vector to hold |Task|s in order to execute them in reverse order
            /// /// (FIFO, instead of LIFO).
            pub temp_tasks_: [u64; 3usize],
        }
        /// Alias for the task closure type.
        pub type LocklessTaskQueue_Task = [u64; 8usize];
        /// Node to model a single-linked list.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct LocklessTaskQueue_Node {
            /// User task.
            pub task: root::vraudio::LocklessTaskQueue_Task,
            /// Pointer to next node.
            pub next: u64,
        }
        #[test]
        fn bindgen_test_layout_LocklessTaskQueue_Node() {
            assert_eq!(
                ::std::mem::size_of::<LocklessTaskQueue_Node>(),
                72usize,
                concat!("Size of: ", stringify!(LocklessTaskQueue_Node))
            );
            assert_eq!(
                ::std::mem::align_of::<LocklessTaskQueue_Node>(),
                8usize,
                concat!("Alignment of ", stringify!(LocklessTaskQueue_Node))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue_Node>())).task as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue_Node),
                    "::",
                    stringify!(task)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue_Node>())).next as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue_Node),
                    "::",
                    stringify!(next)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_LocklessTaskQueue() {
            assert_eq!(
                ::std::mem::size_of::<LocklessTaskQueue>(),
                64usize,
                concat!("Size of: ", stringify!(LocklessTaskQueue))
            );
            assert_eq!(
                ::std::mem::align_of::<LocklessTaskQueue>(),
                8usize,
                concat!("Alignment of ", stringify!(LocklessTaskQueue))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue>())).free_list_head_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue),
                    "::",
                    stringify!(free_list_head_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue>())).task_list_head_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue),
                    "::",
                    stringify!(task_list_head_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue>())).nodes_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue),
                    "::",
                    stringify!(nodes_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<LocklessTaskQueue>())).temp_tasks_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LocklessTaskQueue),
                    "::",
                    stringify!(temp_tasks_)
                )
            );
        }
        extern "C" {
            /// Posts a new task to task queue.
            /// ///
            /// /// @param task Task to process.
            #[link_name = "\u{1}?Post@LocklessTaskQueue@vraudio@@QEAAX$$QEAV?$function@$$A6AXXZ@std@@@Z"]
            pub fn LocklessTaskQueue_Post(
                this: *mut root::vraudio::LocklessTaskQueue,
                task: *mut root::vraudio::LocklessTaskQueue_Task,
            );
        }
        extern "C" {
            /// Executes all tasks on the task queue.
            #[link_name = "\u{1}?Execute@LocklessTaskQueue@vraudio@@QEAAXXZ"]
            pub fn LocklessTaskQueue_Execute(this: *mut root::vraudio::LocklessTaskQueue);
        }
        extern "C" {
            /// Removes all tasks on the task queue.
            #[link_name = "\u{1}?Clear@LocklessTaskQueue@vraudio@@QEAAXXZ"]
            pub fn LocklessTaskQueue_Clear(this: *mut root::vraudio::LocklessTaskQueue);
        }
        extern "C" {
            /// Constructor. Preallocates nodes on the task queue list.
            /// ///
            /// /// @param max_tasks Maximum number of tasks on the task queue.
            #[link_name = "\u{1}??0LocklessTaskQueue@vraudio@@QEAA@_K@Z"]
            pub fn LocklessTaskQueue_LocklessTaskQueue(
                this: *mut root::vraudio::LocklessTaskQueue,
                max_tasks: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DLocklessTaskQueue@vraudio@@QEAAXXZ"]
            pub fn LocklessTaskQueue_LocklessTaskQueue_destructor(
                this: *mut root::vraudio::LocklessTaskQueue,
            );
        }
        impl LocklessTaskQueue {
            #[inline]
            pub unsafe fn Post(&mut self, task: *mut root::vraudio::LocklessTaskQueue_Task) {
                LocklessTaskQueue_Post(self, task)
            }
            #[inline]
            pub unsafe fn Execute(&mut self) {
                LocklessTaskQueue_Execute(self)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                LocklessTaskQueue_Clear(self)
            }
            #[inline]
            pub unsafe fn new(max_tasks: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                LocklessTaskQueue_LocklessTaskQueue(&mut __bindgen_tmp, max_tasks);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                LocklessTaskQueue_LocklessTaskQueue_destructor(self)
            }
        }
        /// Implementation of ResonanceAudioApi interface.
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ResonanceAudioApiImpl {
            pub _base: root::vraudio::ResonanceAudioApi,
            /// Graph manager used to create and destroy sound objects.
            pub graph_manager_: u64,
            /// Manages system wide settings.
            pub system_settings_: root::vraudio::SystemSettings,
            /// Task queue to cache manipulation of all the entities in the system. All
            /// /// tasks are executed from the audio thread.
            pub task_queue_: root::vraudio::LocklessTaskQueue,
            /// Incremental source id counter.
            pub source_id_counter_: u32,
        }
        #[test]
        fn bindgen_test_layout_ResonanceAudioApiImpl() {
            assert_eq!(
                ::std::mem::size_of::<ResonanceAudioApiImpl>(),
                328usize,
                concat!("Size of: ", stringify!(ResonanceAudioApiImpl))
            );
            assert_eq!(
                ::std::mem::align_of::<ResonanceAudioApiImpl>(),
                8usize,
                concat!("Alignment of ", stringify!(ResonanceAudioApiImpl))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResonanceAudioApiImpl>())).graph_manager_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResonanceAudioApiImpl),
                    "::",
                    stringify!(graph_manager_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResonanceAudioApiImpl>())).system_settings_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResonanceAudioApiImpl),
                    "::",
                    stringify!(system_settings_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResonanceAudioApiImpl>())).task_queue_ as *const _
                        as usize
                },
                256usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResonanceAudioApiImpl),
                    "::",
                    stringify!(task_queue_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResonanceAudioApiImpl>())).source_id_counter_ as *const _
                        as usize
                },
                320usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResonanceAudioApiImpl),
                    "::",
                    stringify!(source_id_counter_)
                )
            );
        }
        extern "C" {
            /// Returns the last processed output buffer of the ambisonic mix.
            /// ///
            /// /// @return Pointer to ambisonic output buffer.
            #[link_name = "\u{1}?GetAmbisonicOutputBuffer@ResonanceAudioApiImpl@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn ResonanceAudioApiImpl_GetAmbisonicOutputBuffer(
                this: *const root::vraudio::ResonanceAudioApiImpl,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Returns the last processed output buffer of the stereo (binaural) mix.
            /// ///
            /// /// @return Pointer to stereo output buffer.
            #[link_name = "\u{1}?GetStereoOutputBuffer@ResonanceAudioApiImpl@vraudio@@QEBAPEBVAudioBuffer@2@XZ"]
            pub fn ResonanceAudioApiImpl_GetStereoOutputBuffer(
                this: *const root::vraudio::ResonanceAudioApiImpl,
            ) -> *const root::vraudio::AudioBuffer;
        }
        extern "C" {
            /// Triggers processing of the audio graph with the updated system properties.
            #[link_name = "\u{1}?ProcessNextBuffer@ResonanceAudioApiImpl@vraudio@@QEAAXXZ"]
            pub fn ResonanceAudioApiImpl_ProcessNextBuffer(
                this: *mut root::vraudio::ResonanceAudioApiImpl,
            );
        }
        extern "C" {
            /// Constructor that initializes |ResonanceAudioApi| with system configuration.
            /// ///
            /// /// @param num_channels Number of channels of audio output.
            /// /// @param frames_per_buffer Number of frames per buffer.
            /// /// @param sample_rate_hz System sample rate.
            #[link_name = "\u{1}??0ResonanceAudioApiImpl@vraudio@@QEAA@_K0H@Z"]
            pub fn ResonanceAudioApiImpl_ResonanceAudioApiImpl(
                this: *mut root::vraudio::ResonanceAudioApiImpl,
                num_channels: usize,
                frames_per_buffer: usize,
                sample_rate_hz: ::std::os::raw::c_int,
            );
        }
        impl ResonanceAudioApiImpl {
            #[inline]
            pub unsafe fn GetAmbisonicOutputBuffer(&self) -> *const root::vraudio::AudioBuffer {
                ResonanceAudioApiImpl_GetAmbisonicOutputBuffer(self)
            }
            #[inline]
            pub unsafe fn GetStereoOutputBuffer(&self) -> *const root::vraudio::AudioBuffer {
                ResonanceAudioApiImpl_GetStereoOutputBuffer(self)
            }
            #[inline]
            pub unsafe fn ProcessNextBuffer(&mut self) {
                ResonanceAudioApiImpl_ProcessNextBuffer(self)
            }
            #[inline]
            pub unsafe fn new(
                num_channels: usize,
                frames_per_buffer: usize,
                sample_rate_hz: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ResonanceAudioApiImpl_ResonanceAudioApiImpl(
                    &mut __bindgen_tmp,
                    num_channels,
                    frames_per_buffer,
                    sample_rate_hz,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DResonanceAudioApiImpl@vraudio@@QEAAXXZ"]
            pub fn ResonanceAudioApiImpl_ResonanceAudioApiImpl_destructor(
                this: *mut root::vraudio::ResonanceAudioApiImpl,
            );
        }
        extern "C" {
            /// Obtain processed output buffers.
            #[link_name = "\u{1}?FillInterleavedOutputBuffer@ResonanceAudioApiImpl@vraudio@@UEAA_N_K0PEAM@Z"]
            pub fn ResonanceAudioApiImpl_FillInterleavedOutputBuffer(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
                num_frames: usize,
                buffer_ptr: *mut f32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?FillInterleavedOutputBuffer@ResonanceAudioApiImpl@vraudio@@UEAA_N_K0PEAF@Z"]
            pub fn ResonanceAudioApiImpl_FillInterleavedOutputBuffer1(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
                num_frames: usize,
                buffer_ptr: *mut root::int16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?FillPlanarOutputBuffer@ResonanceAudioApiImpl@vraudio@@UEAA_N_K0PEBQEAM@Z"]
            pub fn ResonanceAudioApiImpl_FillPlanarOutputBuffer(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
                num_frames: usize,
                buffer_ptr: *const *mut f32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?FillPlanarOutputBuffer@ResonanceAudioApiImpl@vraudio@@UEAA_N_K0PEBQEAF@Z"]
            pub fn ResonanceAudioApiImpl_FillPlanarOutputBuffer1(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
                num_frames: usize,
                buffer_ptr: *const *mut root::int16,
            ) -> bool;
        }
        extern "C" {
            /// Listener configuration.
            #[link_name = "\u{1}?SetHeadPosition@ResonanceAudioApiImpl@vraudio@@UEAAXMMM@Z"]
            pub fn ResonanceAudioApiImpl_SetHeadPosition(
                this: *mut ::std::os::raw::c_void,
                x: f32,
                y: f32,
                z: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetHeadRotation@ResonanceAudioApiImpl@vraudio@@UEAAXMMMM@Z"]
            pub fn ResonanceAudioApiImpl_SetHeadRotation(
                this: *mut ::std::os::raw::c_void,
                x: f32,
                y: f32,
                z: f32,
                w: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetMasterVolume@ResonanceAudioApiImpl@vraudio@@UEAAXM@Z"]
            pub fn ResonanceAudioApiImpl_SetMasterVolume(
                this: *mut ::std::os::raw::c_void,
                volume: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetStereoSpeakerMode@ResonanceAudioApiImpl@vraudio@@UEAAX_N@Z"]
            pub fn ResonanceAudioApiImpl_SetStereoSpeakerMode(
                this: *mut ::std::os::raw::c_void,
                enabled: bool,
            );
        }
        extern "C" {
            /// Create and destroy sources.
            #[link_name = "\u{1}?CreateAmbisonicSource@ResonanceAudioApiImpl@vraudio@@UEAAH_K@Z"]
            pub fn ResonanceAudioApiImpl_CreateAmbisonicSource(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
            ) -> root::vraudio::ResonanceAudioApi_SourceId;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateStereoSource@ResonanceAudioApiImpl@vraudio@@UEAAH_K@Z"]
            pub fn ResonanceAudioApiImpl_CreateStereoSource(
                this: *mut ::std::os::raw::c_void,
                num_channels: usize,
            ) -> root::vraudio::ResonanceAudioApi_SourceId;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateSoundObjectSource@ResonanceAudioApiImpl@vraudio@@UEAAHW4RenderingMode@2@@Z"]
            pub fn ResonanceAudioApiImpl_CreateSoundObjectSource(
                this: *mut ::std::os::raw::c_void,
                rendering_mode: root::vraudio::RenderingMode,
            ) -> root::vraudio::ResonanceAudioApi_SourceId;
        }
        extern "C" {
            #[link_name = "\u{1}?DestroySource@ResonanceAudioApiImpl@vraudio@@UEAAXH@Z"]
            pub fn ResonanceAudioApiImpl_DestroySource(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
            );
        }
        extern "C" {
            /// Set source data.
            #[link_name = "\u{1}?SetInterleavedBuffer@ResonanceAudioApiImpl@vraudio@@UEAAXHPEBM_K1@Z"]
            pub fn ResonanceAudioApiImpl_SetInterleavedBuffer(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                audio_buffer_ptr: *const f32,
                num_channels: usize,
                num_frames: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetInterleavedBuffer@ResonanceAudioApiImpl@vraudio@@UEAAXHPEBF_K1@Z"]
            pub fn ResonanceAudioApiImpl_SetInterleavedBuffer1(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                audio_buffer_ptr: *const root::int16,
                num_channels: usize,
                num_frames: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetPlanarBuffer@ResonanceAudioApiImpl@vraudio@@UEAAXHPEBQEBM_K1@Z"]
            pub fn ResonanceAudioApiImpl_SetPlanarBuffer(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                audio_buffer_ptr: *const *const f32,
                num_channels: usize,
                num_frames: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetPlanarBuffer@ResonanceAudioApiImpl@vraudio@@UEAAXHPEBQEBF_K1@Z"]
            pub fn ResonanceAudioApiImpl_SetPlanarBuffer1(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                audio_buffer_ptr: *const *const root::int16,
                num_channels: usize,
                num_frames: usize,
            );
        }
        extern "C" {
            /// Source configuration.
            #[link_name = "\u{1}?SetSourceDistanceAttenuation@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourceDistanceAttenuation(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                distance_attenuation: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSourceDistanceModel@ResonanceAudioApiImpl@vraudio@@UEAAXHW4DistanceRolloffModel@2@MM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourceDistanceModel(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                rolloff: root::vraudio::DistanceRolloffModel,
                min_distance: f32,
                max_distance: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSourcePosition@ResonanceAudioApiImpl@vraudio@@UEAAXHMMM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourcePosition(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                x: f32,
                y: f32,
                z: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSourceRoomEffectsGain@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourceRoomEffectsGain(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                room_effects_gain: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSourceRotation@ResonanceAudioApiImpl@vraudio@@UEAAXHMMMM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourceRotation(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                x: f32,
                y: f32,
                z: f32,
                w: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSourceVolume@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSourceVolume(
                this: *mut ::std::os::raw::c_void,
                source_id: root::vraudio::ResonanceAudioApi_SourceId,
                volume: f32,
            );
        }
        extern "C" {
            /// Sound object configuration.
            #[link_name = "\u{1}?SetSoundObjectDirectivity@ResonanceAudioApiImpl@vraudio@@UEAAXHMM@Z"]
            pub fn ResonanceAudioApiImpl_SetSoundObjectDirectivity(
                this: *mut ::std::os::raw::c_void,
                sound_object_source_id: root::vraudio::ResonanceAudioApi_SourceId,
                alpha: f32,
                order: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSoundObjectListenerDirectivity@ResonanceAudioApiImpl@vraudio@@UEAAXHMM@Z"]
            pub fn ResonanceAudioApiImpl_SetSoundObjectListenerDirectivity(
                this: *mut ::std::os::raw::c_void,
                sound_object_source_id: root::vraudio::ResonanceAudioApi_SourceId,
                alpha: f32,
                order: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSoundObjectNearFieldEffectGain@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSoundObjectNearFieldEffectGain(
                this: *mut ::std::os::raw::c_void,
                sound_object_source_id: root::vraudio::ResonanceAudioApi_SourceId,
                gain: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSoundObjectOcclusionIntensity@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSoundObjectOcclusionIntensity(
                this: *mut ::std::os::raw::c_void,
                sound_object_source_id: root::vraudio::ResonanceAudioApi_SourceId,
                intensity: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetSoundObjectSpread@ResonanceAudioApiImpl@vraudio@@UEAAXHM@Z"]
            pub fn ResonanceAudioApiImpl_SetSoundObjectSpread(
                this: *mut ::std::os::raw::c_void,
                sound_object_source_id: root::vraudio::ResonanceAudioApi_SourceId,
                spread_deg: f32,
            );
        }
        extern "C" {
            /// Room effects configuration.
            #[link_name = "\u{1}?EnableRoomEffects@ResonanceAudioApiImpl@vraudio@@UEAAX_N@Z"]
            pub fn ResonanceAudioApiImpl_EnableRoomEffects(
                this: *mut ::std::os::raw::c_void,
                enable: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetReflectionProperties@ResonanceAudioApiImpl@vraudio@@UEAAXAEBUReflectionProperties@2@@Z"]
            pub fn ResonanceAudioApiImpl_SetReflectionProperties(
                this: *mut ::std::os::raw::c_void,
                reflection_properties: *const root::vraudio::ReflectionProperties,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetReverbProperties@ResonanceAudioApiImpl@vraudio@@UEAAXAEBUReverbProperties@2@@Z"]
            pub fn ResonanceAudioApiImpl_SetReverbProperties(
                this: *mut ::std::os::raw::c_void,
                reverb_properties: *const root::vraudio::ReverbProperties,
            );
        }
    }
    pub mod Eigen {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type conditional_type<Then> = Then;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub struct traits {
                pub _address: u8,
            }
            /// \internal The reference selector for template expressions. The idea is that we don't
            /// need to use references for expressions since they are light weight proxy
            /// objects which should generate no copying overhead.
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub struct ref_selector {
                pub _address: u8,
            }
            pub type ref_selector_type = u8;
            pub type ref_selector_non_const_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub struct dense_xpr_base {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub struct default_packet_traits {
                pub _address: u8,
            }
            pub const default_packet_traits_HasHalfPacket:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasAdd:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasSub:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasMul:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasNegate:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasAbs:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasArg:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasAbs2:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasMin:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasMax:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasConj:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasSetLinear:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 1;
            pub const default_packet_traits_HasBlend:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasDiv:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasSqrt:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasRsqrt:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasExp:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasExpm1:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasLog:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasLog1p:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasLog10:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasPow:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasSin:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasCos:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasTan:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasASin:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasACos:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasATan:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasSinh:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasCosh:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasTanh:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasLGamma:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasDiGamma:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasZeta:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasPolygamma:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasErf:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasErfc:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasI0e:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasI1e:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasIGamma:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasIGammaDerA:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasGammaSampleDerAlpha:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasIGammac:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasBetaInc:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasRound:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasFloor:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasCeil:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub const default_packet_traits_HasSign:
                root::Eigen::internal::default_packet_traits__bindgen_ty_1 = 0;
            pub type default_packet_traits__bindgen_ty_1 = i32;
            #[test]
            fn bindgen_test_layout_default_packet_traits() {
                assert_eq!(
                    ::std::mem::size_of::<default_packet_traits>(),
                    1usize,
                    concat!("Size of: ", stringify!(default_packet_traits))
                );
                assert_eq!(
                    ::std::mem::align_of::<default_packet_traits>(),
                    1usize,
                    concat!("Alignment of ", stringify!(default_packet_traits))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub struct packet_traits {
                pub _address: u8,
            }
            pub type packet_traits_type<T> = T;
            pub type packet_traits_half<T> = T;
            pub const packet_traits_Vectorizable:
                root::Eigen::internal::packet_traits__bindgen_ty_1 = 0;
            pub const packet_traits_size: root::Eigen::internal::packet_traits__bindgen_ty_1 = 0;
            pub const packet_traits_AlignedOnScalar:
                root::Eigen::internal::packet_traits__bindgen_ty_1 = 0;
            pub const packet_traits_HasHalfPacket:
                root::Eigen::internal::packet_traits__bindgen_ty_1 = 0;
            pub type packet_traits__bindgen_ty_1 = i32;
            pub const packet_traits_HasAdd: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasSub: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasMul: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasNegate: root::Eigen::internal::packet_traits__bindgen_ty_2 =
                0;
            pub const packet_traits_HasAbs: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasAbs2: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasMin: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasMax: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasConj: root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub const packet_traits_HasSetLinear:
                root::Eigen::internal::packet_traits__bindgen_ty_2 = 0;
            pub type packet_traits__bindgen_ty_2 = i32;
        }
        /// \class NumTraits
        /// \ingroup Core_Module
        ///
        /// \brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.
        ///
        /// \tparam T the numeric type at hand
        ///
        /// This class stores enums, typedefs and static methods giving information about a numeric type.
        ///
        /// The provided data consists of:
        /// \li A typedef \c Real, giving the "real part" type of \a T. If \a T is already real,
        /// then \c Real is just a typedef to \a T. If \a T is \c std::complex<U> then \c Real
        /// is a typedef to \a U.
        /// \li A typedef \c NonInteger, giving the type that should be used for operations producing non-integral values,
        /// such as quotients, square roots, etc. If \a T is a floating-point type, then this typedef just gives
        /// \a T again. Note however that many Eigen functions such as internal::sqrt simply refuse to
        /// take integers. Outside of a few cases, Eigen doesn't do automatic type promotion. Thus, this typedef is
        /// only intended as a helper for code that needs to explicitly promote types.
        /// \li A typedef \c Literal giving the type to use for numeric literals such as "2" or "0.5". For instance, for \c std::complex<U>, Literal is defined as \c U.
        /// Of course, this type must be fully compatible with \a T. In doubt, just use \a T here.
        /// \li A typedef \a Nested giving the type to use to nest a value inside of the expression tree. If you don't know what
        /// this means, just use \a T here.
        /// \li An enum value \a IsComplex. It is equal to 1 if \a T is a \c std::complex
        /// type, and to 0 otherwise.
        /// \li An enum value \a IsInteger. It is equal to \c 1 if \a T is an integer type such as \c int,
        /// and to \c 0 otherwise.
        /// \li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed
        /// to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.
        /// Stay vague here. No need to do architecture-specific stuff. If you don't know what this means, just use \c Eigen::HugeCost.
        /// \li An enum value \a IsSigned. It is equal to \c 1 if \a T is a signed type and to 0 if \a T is unsigned.
        /// \li An enum value \a RequireInitialization. It is equal to \c 1 if the constructor of the numeric type \a T must
        /// be called, and to 0 if it is safe not to call it. Default is 0 if \a T is an arithmetic type, and 1 otherwise.
        /// \li An epsilon() function which, unlike <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon">std::numeric_limits::epsilon()</a>,
        /// it returns a \a Real instead of a \a T.
        /// \li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default
        /// value by the fuzzy comparison operators.
        /// \li highest() and lowest() functions returning the highest and lowest possible values respectively.
        /// \li digits10() function returning the number of decimal digits that can be represented without change. This is
        /// the analogue of <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/digits10">std::numeric_limits<T>::digits10</a>
        /// which is used as the default implementation if specialized.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct GenericNumTraits {
            pub _address: u8,
        }
        pub const GenericNumTraits_IsInteger: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_IsSigned: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_IsComplex: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_RequireInitialization:
            root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_ReadCost: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_AddCost: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub const GenericNumTraits_MulCost: root::Eigen::GenericNumTraits__bindgen_ty_1 = 0;
        pub type GenericNumTraits__bindgen_ty_1 = i32;
        pub type GenericNumTraits_Real<T> = T;
        pub type GenericNumTraits_NonInteger = u8;
        pub type GenericNumTraits_Nested<T> = T;
        pub type GenericNumTraits_Literal<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct NumTraits {
            pub _address: u8,
        }
        pub mod placeholders {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PlainObjectBase {
            pub m_storage: u8,
        }
        pub const PlainObjectBase_Options: root::Eigen::PlainObjectBase__bindgen_ty_1 = 0;
        pub type PlainObjectBase__bindgen_ty_1 = i32;
        pub type PlainObjectBase_Base = root::Eigen::internal::dense_xpr_base;
        pub type PlainObjectBase_StorageKind = root::Eigen::internal::traits;
        pub type PlainObjectBase_Scalar = root::Eigen::internal::traits;
        pub type PlainObjectBase_PacketScalar = root::Eigen::internal::packet_traits;
        pub type PlainObjectBase_RealScalar = root::Eigen::NumTraits;
        pub type PlainObjectBase_DenseType<Derived> = Derived;
        pub type PlainObjectBase_MapType = u8;
        pub type PlainObjectBase_ConstMapType = u8;
        pub type PlainObjectBase_AlignedMapType = u8;
        pub type PlainObjectBase_ConstAlignedMapType = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PlainObjectBase_StridedMapType {
            pub _address: u8,
        }
        pub type PlainObjectBase_StridedMapType_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PlainObjectBase_StridedConstMapType {
            pub _address: u8,
        }
        pub type PlainObjectBase_StridedConstMapType_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PlainObjectBase_StridedAlignedMapType {
            pub _address: u8,
        }
        pub type PlainObjectBase_StridedAlignedMapType_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PlainObjectBase_StridedConstAlignedMapType {
            pub _address: u8,
        }
        pub type PlainObjectBase_StridedConstAlignedMapType_type = u8;
        pub const PlainObjectBase_NeedsToAlign: root::Eigen::PlainObjectBase__bindgen_ty_2 = 0;
        pub type PlainObjectBase__bindgen_ty_2 = i32;
        pub type PlainObjectBase_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
        pub const PlainObjectBase_IsPlainObjectBase: root::Eigen::PlainObjectBase__bindgen_ty_3 = 0;
        pub type PlainObjectBase__bindgen_ty_3 = i32;
        /// \brief Base class typedef.
        /// \sa PlainObjectBase
        pub type Matrix_Base = root::Eigen::PlainObjectBase;
        pub const Matrix_Options: root::Eigen::Matrix__bindgen_ty_1 = 0;
        pub type Matrix__bindgen_ty_1 = i32;
        pub type Matrix_Scalar = root::Eigen::internal::traits;
        pub type Matrix_RealScalar = root::Eigen::NumTraits;
        pub type Matrix_CoeffReturnType = root::Eigen::Matrix_Base;
        pub type Matrix_Nested = root::Eigen::internal::ref_selector;
        pub type Matrix_StorageKind = root::Eigen::internal::traits;
        pub type Matrix_StorageIndex = root::Eigen::internal::traits;
        pub const Matrix_CompileTimeTraits_RowsAtCompileTime:
            root::Eigen::Matrix_CompileTimeTraits = 0;
        pub const Matrix_CompileTimeTraits_ColsAtCompileTime:
            root::Eigen::Matrix_CompileTimeTraits = 0;
        pub const Matrix_CompileTimeTraits_Flags: root::Eigen::Matrix_CompileTimeTraits = 0;
        pub const Matrix_CompileTimeTraits_SizeAtCompileTime:
            root::Eigen::Matrix_CompileTimeTraits = 0;
        pub const Matrix_CompileTimeTraits_MaxSizeAtCompileTime:
            root::Eigen::Matrix_CompileTimeTraits = 0;
        pub const Matrix_CompileTimeTraits_IsVectorAtCompileTime:
            root::Eigen::Matrix_CompileTimeTraits = 0;
        pub type Matrix_CompileTimeTraits = i32;
        pub type Matrix_PacketScalar = root::Eigen::Matrix_Base;
        pub type Matrix_PlainObject = root::Eigen::Matrix_Base;
        pub type Map_Base = u8;
        pub type Map_Scalar = root::Eigen::internal::traits;
        pub type Map_RealScalar = root::Eigen::NumTraits;
        pub type Map_CoeffReturnType = root::Eigen::Map_Base;
        pub type Map_Nested = root::Eigen::internal::ref_selector;
        pub type Map_StorageKind = root::Eigen::internal::traits;
        pub type Map_StorageIndex = root::Eigen::internal::traits;
        pub const Map_CompileTimeTraits_RowsAtCompileTime: root::Eigen::Map_CompileTimeTraits = 0;
        pub const Map_CompileTimeTraits_ColsAtCompileTime: root::Eigen::Map_CompileTimeTraits = 0;
        pub const Map_CompileTimeTraits_Flags: root::Eigen::Map_CompileTimeTraits = 0;
        pub const Map_CompileTimeTraits_SizeAtCompileTime: root::Eigen::Map_CompileTimeTraits = 0;
        pub const Map_CompileTimeTraits_MaxSizeAtCompileTime: root::Eigen::Map_CompileTimeTraits =
            0;
        pub const Map_CompileTimeTraits_IsVectorAtCompileTime: root::Eigen::Map_CompileTimeTraits =
            0;
        pub type Map_CompileTimeTraits = i32;
        pub type Map_PacketScalar = root::Eigen::Map_Base;
        pub type Map_PointerType = root::Eigen::Map_Base;
        pub type Map_PointerArgType = root::Eigen::Map_PointerType;
        pub const RotationBase_Dim: root::Eigen::RotationBase__bindgen_ty_1 = 0;
        pub type RotationBase__bindgen_ty_1 = i32;
        /// the scalar type of the coefficients
        pub type RotationBase_Scalar = root::Eigen::internal::traits;
        /// corresponding linear transformation matrix type
        pub type RotationBase_RotationMatrixType = u8;
        pub type RotationBase_VectorType = u8;
        /// \geometry_module \ingroup Geometry_Module
        /// \class QuaternionBase
        /// \brief Base class for quaternion expressions
        /// \tparam Derived derived type (CRTP)
        /// \sa class Quaternion
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct QuaternionBase {
            pub _address: u8,
        }
        pub type QuaternionBase_Base = u8;
        pub type QuaternionBase_Scalar = root::Eigen::internal::traits;
        pub type QuaternionBase_RealScalar = root::Eigen::NumTraits;
        pub type QuaternionBase_Coefficients = root::Eigen::internal::traits;
        pub type QuaternionBase_CoeffReturnType = root::Eigen::QuaternionBase_Coefficients;
        pub type QuaternionBase_NonConstCoeffReturnType = u8;
        pub const QuaternionBase_Flags: root::Eigen::QuaternionBase__bindgen_ty_1 = 0;
        pub type QuaternionBase__bindgen_ty_1 = i32;
        /// the type of a 3D vector
        pub type QuaternionBase_Vector3 = u8;
        /// the equivalent rotation matrix type
        pub type QuaternionBase_Matrix3 = u8;
        /// the equivalent angle-axis type
        pub type QuaternionBase_AngleAxisType =
            root::Eigen::AngleAxis<root::Eigen::QuaternionBase_Scalar>;
        pub type Quaternion_Base = root::Eigen::QuaternionBase;
        pub const Quaternion_NeedsAlignment: root::Eigen::Quaternion__bindgen_ty_1 = 0;
        pub type Quaternion__bindgen_ty_1 = i32;
        pub type Quaternion_Scalar<_Scalar> = _Scalar;
        pub type Quaternion_Coefficients = root::Eigen::internal::traits;
        pub type Quaternion_AngleAxisType = root::Eigen::Quaternion_Base;
        pub type Quaternion_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct AngleAxis<_Scalar> {
            pub m_axis: root::Eigen::AngleAxis_Vector3,
            pub m_angle: root::Eigen::AngleAxis_Scalar<_Scalar>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Scalar>>,
        }
        pub type AngleAxis_Base = u8;
        pub const AngleAxis_Dim: root::Eigen::AngleAxis__bindgen_ty_1 = 0;
        pub type AngleAxis__bindgen_ty_1 = i32;
        /// the scalar type of the coefficients
        pub type AngleAxis_Scalar<_Scalar> = _Scalar;
        pub type AngleAxis_Matrix3 = u8;
        pub type AngleAxis_Vector3 = u8;
        pub type AngleAxis_QuaternionType = u8;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PFFFT_Setup {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct _bindgen_ty_24 {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_AngleAxis_open0_float_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::Eigen::AngleAxis<f32>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::Eigen::AngleAxis<f32>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::Eigen::AngleAxis<f32>>(),
            4usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::Eigen::AngleAxis<f32>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_SubscriberNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_PublisherNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_SubscriberNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_PublisherNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Output_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation()
    {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Output>(),
            48usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Output>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Input_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation()
    {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Input>(),
            88usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Input)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Input>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Input)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Output_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Output>(),
            48usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Output>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_PublisherNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_2(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_PublisherNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_3(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Output_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_2(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Output>(),
            48usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Output>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Output_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_3(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Output>(),
            48usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Output>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Output)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_SubscriberNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_2(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::SubscriberNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::SubscriberNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_PublisherNode_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_4(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::PublisherNode>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::PublisherNode)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Node_Input_open0_ptr_const_vraudio__AudioBuffer_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::vraudio::Node_Input>(),
            88usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::vraudio::Node_Input)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::vraudio::Node_Input>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::vraudio::Node_Input)
            )
        );
    }
}
